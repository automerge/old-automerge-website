"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[398],{3199:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var t=o(4848),r=o(8453);const a={},s="Automerge Repo 2.0",i={permalink:"/blog/2025/05/13/automerge-repoo-2",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/blog/2025-05-13-automerge-repoo-2.md",source:"@site/blog/2025-05-13-automerge-repoo-2.md",title:"Automerge Repo 2.0",description:"Automerge Repo was built to improve the developer experience of building Automerge applications by taking common patterns in Automerge applications and packaging them as a reusable library. This has worked really well, getting storage and networking up and running with Automerge Repo is very quick. We wanted to repeat the trick.",date:"2025-05-13T00:00:00.000Z",tags:[],readingTime:4.59,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,nextItem:{title:"Automerge Anywhere",permalink:"/blog/2024/08/23/wasm-packaging"}},d={authorsImageUrls:[]},c=[{value:"<code>find</code> and <code>findWithProgress</code>",id:"find-and-findwithprogress",level:2},{value:"DocHandle version control methods",id:"dochandle-version-control-methods",level:2},{value:"Suspense Support for React",id:"suspense-support-for-react",level:2},{value:"React and Vanilla JS meta packages",id:"react-and-vanilla-js-meta-packages",level:2},{value:"Papercuts",id:"papercuts",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Automerge Repo was built to improve the developer experience of building Automerge applications by taking common patterns in Automerge applications and packaging them as a reusable library. This has worked really well, getting storage and networking up and running with Automerge Repo is very quick. We wanted to repeat the trick."}),"\n",(0,t.jsx)(n.p,{children:"Over the last year we've been working on taking advantage of the rich history which Automerge records in order to build sophisticated version control workflows for general data types. In doing this we encountered a variety of common tasks related to examining the history of a document which have to be done in userland - so we've added these methods to Automerge Repo."}),"\n",(0,t.jsxs)(n.p,{children:["At the same time, we've also noticed a number of papercuts which lead to extra boilerplat in Automerge Repo applications. Firstly ",(0,t.jsx)(n.code,{children:"Repo.find"})," returns a ",(0,t.jsx)(n.code,{children:"DocHandle"})," immediately and the caller is responsible for waiting until it is ready. Secondly, there are a lot of different packages to install in order to get up and running with common network and storage setups. We've tried to address all of these, read on for more details."]}),"\n",(0,t.jsxs)(n.h2,{id:"find-and-findwithprogress",children:[(0,t.jsx)(n.code,{children:"find"})," and ",(0,t.jsx)(n.code,{children:"findWithProgress"})]}),"\n",(0,t.jsxs)(n.p,{children:["One of the biggest changes is that ",(0,t.jsx)(n.code,{children:"Repo.find"})," is now asynchronous, returning a ",(0,t.jsx)(n.code,{children:"Promise<DocHandle<T>>"})," which resolves to a ",(0,t.jsx)(n.code,{children:"DocHandle"})," which is ready to use. This is in contrast to the 1.0 API which immediately returned a ",(0,t.jsx)(n.code,{children:"DocHandle<T>"}),", but then required you to wait until the ",(0,t.jsx)(n.code,{children:"DocHandle"})," was ready before actually trying to access the document the handle represents. This simplifies a lot of code and removes some footguns."]}),"\n",(0,t.jsx)(n.p,{children:"This"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const handle = repo.find(<url>)\nawait handle.whenReady()\nconsole.log(handle.docSync())\n"})}),"\n",(0,t.jsx)(n.p,{children:"becomes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const handle = await repo.find(<url>)\nconsole.log(handle.doc())\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes though, you don't want to await the result of ",(0,t.jsx)(n.code,{children:"find"}),". Maybe you are not in an asynchronous context, or maybe you want to have some indication of the progress a request is making. For this you can use the new ",(0,t.jsx)(n.code,{children:"Repo.findWithProgress"}),". This method returns a ",(0,t.jsx)(n.code,{children:"FindProgress<T>"})," which is a little state machine that steps through the various stages of looking for a document (loading from storage, requesting from the network, ready, unavailable, etc.). This allows you to build more complex loading UIs."]}),"\n",(0,t.jsx)(n.h2,{id:"dochandle-version-control-methods",children:"DocHandle version control methods"}),"\n",(0,t.jsx)(n.p,{children:"Automerge records the entire history of a document at a granular level and this is what allows us to build sophisticated version control on top of it. To date, the API to achieve these things has been a little low level. In Automerge Repo 2.0 we implement a few routines which are common to most applications."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.view(<heads>)"})," returns a ",(0,t.jsx)(n.code,{children:"DocHandle"}),' which is "frozen" at the point in time represented by ',(0,t.jsx)(n.code,{children:"heads"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.history()"})," returns an array of Automerge URLs which can be passed to ",(0,t.jsx)(n.code,{children:"DocHandle.view(<url>)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.diff(<url | DocHandle>)"})," takes either a URL returned by ",(0,t.jsx)(n.code,{children:"history"})," or another ",(0,t.jsx)(n.code,{children:"DocHandle"})," and produces a set of patches representing the diff."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This can be used like so:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const current = repo.find(<url>)\nconst history = current.history()\n// now go back one step in history\nconst lastVersion = current.view(history[history.len() - 1])\n// Get the diff \nconst diff = lastVersion.diff(original)\n// Now visualise the diff somehow (in a text editor you might do a line based diff for example)\nvisualiseDiff(diff)\n"})}),"\n",(0,t.jsxs)(n.p,{children:['For an example of how to use these APIs to build a "rewind" bar, take a look at ',(0,t.jsxs)(n.a,{href:"https://github.com/automerge/automerge-repo-quickstart/tree/rewind",children:["the ",(0,t.jsx)(n.code,{children:"rewind"})," branch of the quickstart repo"]})]}),"\n",(0,t.jsx)(n.h2,{id:"suspense-support-for-react",children:"Suspense Support for React"}),"\n",(0,t.jsxs)(n.p,{children:["The React hooks now have support for suspense. To use it, simply pass ",(0,t.jsx)(n.code,{children:"{ suspense: true }"})," as the second argument to the hook. One nice benefit of this approach is that you don't need to worry about checking if the document is initialized: if"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useHandle"})," is now called ",(0,t.jsx)(n.code,{children:"useDocHandle"})," and integrates with React suspense."]}),"\n",(0,t.jsxs)(n.li,{children:["Added ",(0,t.jsx)(n.code,{children:"useHandles"})," to load many handles at once"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useDocument"})," and ",(0,t.jsx)(n.code,{children:"useDocuments"})," now integrate with React suspense so you don't need to have special code to handle the loading state"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"react-and-vanilla-js-meta-packages",children:"React and Vanilla JS meta packages"}),"\n",(0,t.jsx)(n.p,{children:"Automerge is designed for modularity; a powerful CRDT at the core and an extensible document management system built to allow you to bring your own storage and networking."}),"\n",(0,t.jsxs)(n.p,{children:["There are a bunch of packages in the ",(0,t.jsx)(n.code,{children:"automerge-repo"})," ecosystem which most applications need. For example, a typical react application will start with this code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Repo } from "@automerge/automerge-repo"\nimport { BrowserWebSocketClientAdapter } from "@automerge/automerge-repo-network-websocket"\nimport { BroadcastChannelNetworkAdapter } from "@automerge/automerge-repo-network-broadcastchannel"\nimport { IndexedDbStorageAdapter } from "@automerge/automerge-repo-storage-indexeddb"\nimport { useDocument, useDocuments, useHandle, useHandles } from "@automerge/automerge-repo-react-hooks"\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is a lot of boilerplate and a lot of separate packages to install and update. To reduce this noise we've created two packages which just re-export these names - one for React applications and one for vanilla JS applications."}),"\n",(0,t.jsx)(n.p,{children:"A react application now looks a bit like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import {\n    Repo,\n    WebSocketClientAdapter,\n    IndexedDbStorageAdapter,\n    useDocument\n} from "@automerge/react"\n\n// Create a pre-configured repo instance\nconst repo = Repo({\n  network: [new WebSocketClientAdapter("ws://localhost:8080")]\n  storage: new IndexedDbStorageAdapter()\n})\n\n// Use in your React components\nfunction MyComponent() {\n  const doc = useDocument(repo, "my-doc-id")\n\n  if (!doc) return <div>Loading...</div>\n\n  return <div>{doc.content}</div>\n}\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"Whilst a vanilla app would look like"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import {\n  Repo,\n  MessageChannelNetworkAdapter,\n  IndexedDBStorageAdapter,\n  WebSocketClientAdapter,\n} from "@automerge/vanillajs"\n\n// Create a repo with your chosen adapters\nconst repo = new Repo({\n  network: [\n    new MessageChannelNetworkAdapter(/* your message channel to another repo here */),\n    new IndexedDBStorageAdapter(),\n    new WebSocketClientAdapter("wss://sync.automerge.org"),\n  ],\n})\n\n// rest of the application\n'})}),"\n",(0,t.jsx)(n.h2,{id:"papercuts",children:"Papercuts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"BrowserWebSocketClientAdapter"})," and ",(0,t.jsx)(n.code,{children:"NodeWSServerAdapter"}),"s are now called ",(0,t.jsx)(n.code,{children:"WebSocketClientAdapter"})," and ",(0,t.jsx)(n.code,{children:"WebSocketServerAdpater"})," respectively"]}),"\n",(0,t.jsx)(n.li,{children:"Updated the svelte integration to Svelte 5"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var t=o(6540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);