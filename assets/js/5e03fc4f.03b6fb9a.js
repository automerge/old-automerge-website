"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4285],{4331:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var o=n(758);const r={},c=o.createContext(r);function s(e){const t=o.useContext(c);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(c.Provider,{value:t},e.children)}},9664:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"reference/documents/text","title":"Text","description":"Automerge provides support for collaborative text editing. Under the hood, whenever you create a string in Automerge you are creating a collaborative text object which supports merging concurrent changes to the string.","source":"@site/docs/reference/documents/text.md","sourceDirName":"reference/documents","slug":"/reference/documents/text","permalink":"/docs/reference/documents/text","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/reference/documents/text.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Lists","permalink":"/docs/reference/documents/lists"},"next":{"title":"Rich Text","permalink":"/docs/reference/documents/rich_text"}}');var r=n(6070),c=n(4331);const s={sidebar_position:4},i="Text",a={},d=[{value:"Using <code>updateText</code> when you can&#39;t use <code>splice</code>",id:"using-updatetext-when-you-cant-use-splice",level:2}];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"text",children:"Text"})}),"\n",(0,r.jsxs)(t.p,{children:["Automerge provides support for collaborative text editing. Under the hood, whenever you create a ",(0,r.jsx)(t.code,{children:"string"})," in Automerge you are creating a collaborative text object which supports merging concurrent changes to the ",(0,r.jsx)(t.code,{children:"string"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["If you want changes to a ",(0,r.jsx)(t.code,{children:"string"})," to be collaborative, you should use ",(0,r.jsx)(t.code,{children:"Automerge.splice"})," to modify the string."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'import  * as Automerge  from "@automerge/automerge"\n\nlet doc = Automerge.from({text: "hello world"})\n\n// Fork the doc and make a change\nlet forked = Automerge.clone(doc)\nforked = Automerge.change(forked, d => {\n    // Insert \' wonderful\' at index 5, don\'t delete anything\n    Automerge.splice(d, ["text"], 5, 0, " wonderful")\n})\n\n// Make a concurrent change on the original document\ndoc = Automerge.change(doc, d => {\n    // Insert at the start, delete 5 characters (the "hello")\n    Automerge.splice(d, ["text"], 0, 5, "Greetings")\n})\n\n// Merge the changes\ndoc = Automerge.merge(doc, forked)\n\nconsole.log(doc.text) // "Greetings wonderful world"\n'})}),"\n",(0,r.jsxs)(t.h2,{id:"using-updatetext-when-you-cant-use-splice",children:["Using ",(0,r.jsx)(t.code,{children:"updateText"})," when you can't use ",(0,r.jsx)(t.code,{children:"splice"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"splice"})," works in terms of low level input events, sometimes it's hard to get hold of these. For example, in a simple web form the ",(0,r.jsx)(t.code,{children:"input"})," event is fired every time an ",(0,r.jsx)(t.code,{children:"input"})," element changes, but the value of the event is the whole content of the text box. In this case you can use ",(0,r.jsx)(t.code,{children:"Automerge.updateText"}),", which will figure out what has changed for you and convert the changes into ",(0,r.jsx)(t.code,{children:"splice"})," operations internally."]}),"\n",(0,r.jsx)(t.p,{children:"Imagine you have a simple text box:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:'<input id="myInput" type="text" value="hello world">\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Then with this HTML you can use ",(0,r.jsx)(t.code,{children:"updateText"})," to make the text box collaborative:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'\nconst handle: DocHandle<{text: string}> = ... // some how get a DocHandle\n\nconst input = document.getElementById("input")!\n\ninput.value = handle.docSync()!.text!\n\n// On every keystroke use `updateText` to update the value of the text field\ninput.oninput = (e) => {\n    handle.change((doc) => {\n        // @ts-ignore\n        const newValue: string = e.target.value\n        console.log("newValue", newValue)\n        am.updateText(doc, ["text"], newValue)\n    })\n}\n\n// Any time the document changes, update the value of the text field\nhandle.on("change", () => {\n    // @ts-ignore\n    input.value = handle.docSync()!.text!\n})\n'})}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"updateText"})," works best when you call it as frequently as possible. If the text has changed a lot between calls to ",(0,r.jsx)(t.code,{children:"updateText"})," (for example if you were calling it in ",(0,r.jsx)(t.code,{children:"onchange"}),") the diff will not merge well with concurrent changes. The best case is to call it after every keystroke."]})})]})}function u(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);