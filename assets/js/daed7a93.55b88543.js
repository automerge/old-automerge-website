"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8965],{8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>i});var o=r(6540);const a={},n=o.createContext(a);function s(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(n.Provider,{value:t},e.children)}},9320:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"reference/the_js_packages","title":"The JavaScript packages","description":"The javascript API has been through several iterations and is currently split over a few libraries. This page describes how all these pieces fit together.","source":"@site/docs/reference/the_js_packages.md","sourceDirName":"reference","slug":"/reference/the_js_packages","permalink":"/docs/reference/the_js_packages","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/reference/the_js_packages.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Library Initialization","permalink":"/docs/reference/library_initialization"},"next":{"title":"Document Data Model","permalink":"/docs/reference/documents/"}}');var a=r(4848),n=r(8453);const s={sidebar_position:3},i="The JavaScript packages",c={},d=[{value:"Recommended Usage",id:"recommended-usage",level:2},{value:"The <code>next</code> API",id:"the-next-api",level:2},{value:"Differences from stable",id:"differences-from-stable",level:3},{value:"Using the next API",id:"using-the-next-api",level:3},{value:"Subpath Exports",id:"subpath-exports",level:4},{value:"The <code>{ next }</code> module",id:"the--next--module",level:4},{value:"How we got here",id:"how-we-got-here",level:2},{value:"Automerge Classic",id:"automerge-classic",level:3},{value:"<code>@automerge/automerge-wasm</code> and <code>@automerge/automerge</code>",id:"automergeautomerge-wasm-and-automergeautomerge",level:3},{value:"<code>@automerge/automerge-repo</code>",id:"automergeautomerge-repo",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"the-javascript-packages",children:"The JavaScript packages"})}),"\n",(0,a.jsx)(t.p,{children:"The javascript API has been through several iterations and is currently split over a few libraries. This page describes how all these pieces fit together."}),"\n",(0,a.jsx)(t.h2,{id:"recommended-usage",children:"Recommended Usage"}),"\n",(0,a.jsx)(t.p,{children:"If you just want to know how to use Automerge in greenfield applications, here's how the library is intended to be used:"}),"\n",(0,a.jsxs)(t.p,{children:["Install both the ",(0,a.jsx)(t.code,{children:"@automerge/automerge"})," and ",(0,a.jsx)(t.code,{children:"@automerge/automerge-repo"})," packages. Then install the networking and storage plugins you need (typically ",(0,a.jsx)(t.code,{children:"@automerge/automerge-repo-network-*"})," and ",(0,a.jsx)(t.code,{children:"@automerge/automerge-repo-storage-*"}),") packages. Take a look at the cookbook for examples of different ways of using these."]}),"\n",(0,a.jsxs)(t.p,{children:["When you're making changes to an automerge document you should use ",(0,a.jsxs)(t.a,{href:"#the-next-api",children:["the ",(0,a.jsx)(t.code,{children:"next"})," API"]})]}),"\n",(0,a.jsxs)(t.h2,{id:"the-next-api",children:["The ",(0,a.jsx)(t.code,{children:"next"})," API"]}),"\n",(0,a.jsx)(t.p,{children:'Over time we have made a number of changes to the automerge API which are not backwards compatible. In order to not break compatibility we have exposed the new API under a sub module of the library, this submodule used to be called "unstable" to reflect that we were not sure about it - but we\'re now fairly sure we like it so we\'re calling it "next" in expectation that it\'s what the next major version of automerge will look like.'}),"\n",(0,a.jsx)(t.h3,{id:"differences-from-stable",children:"Differences from stable"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["In the old API javascript strings are represented as scalar strings (see the ",(0,a.jsx)(t.a,{href:"/docs/reference/documents/",children:"data model"}),' for details) whilst in "next" javascript strings are ',(0,a.jsx)(t.code,{children:"Text"})," sequences (i.e. they support concurrent insertions and deletions). This means that you should use ",(0,a.jsx)(t.code,{children:"next.splice"})," to modify strings in the ",(0,a.jsx)(t.code,{children:"next"})," API. Scalar strings in the ",(0,a.jsx)(t.code,{children:"next"})," API are represented as instances of the ",(0,a.jsx)(t.code,{children:"RawString"})," class."]}),"\n",(0,a.jsxs)(t.li,{children:["The next API exposes the ",(0,a.jsx)(t.code,{children:"diff"})," and ",(0,a.jsx)(t.code,{children:"changeAt"})," methods"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"using-the-next-api",children:"Using the next API"}),"\n",(0,a.jsx)(t.p,{children:"There are two ways to use the next API"}),"\n",(0,a.jsx)(t.h4,{id:"subpath-exports",children:"Subpath Exports"}),"\n",(0,a.jsx)(t.p,{children:"If you are either using JavaScript in a modern browser or on node > 16 then you can do the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'import * as A from "@automerge/automerge/next";\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Note that for this to work in typescript you will need to have the following in your ",(0,a.jsx)(t.code,{children:"tsconfig.json"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'    ...\n    "module": "NodeNext",\n    "moduleResolution": "Node16",\n    ...\n'})}),"\n",(0,a.jsxs)(t.h4,{id:"the--next--module",children:["The ",(0,a.jsx)(t.code,{children:"{ next }"})," module"]}),"\n",(0,a.jsxs)(t.p,{children:["If for whatever reason you can't use ",(0,a.jsx)(t.code,{children:"@automerge/automerge/next"})," then you can do this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'import { next as A } from "@automerge/automerge";\n'})}),"\n",(0,a.jsx)(t.h2,{id:"how-we-got-here",children:"How we got here"}),"\n",(0,a.jsx)(t.h3,{id:"automerge-classic",children:"Automerge Classic"}),"\n",(0,a.jsxs)(t.p,{children:["The first version of automerge was implemented in pure javascript and is what we now call automerge Classic. You can find it ",(0,a.jsx)(t.a,{href:"https://www.npmjs.com/package/automerge",children:"on NPM"})," and ",(0,a.jsx)(t.a,{href:"https://github.com/automerge/automerge-classic",children:"GitHub"}),". This project went through several iterations which changed quite dramatically."]}),"\n",(0,a.jsxs)(t.h3,{id:"automergeautomerge-wasm-and-automergeautomerge",children:[(0,a.jsx)(t.code,{children:"@automerge/automerge-wasm"})," and ",(0,a.jsx)(t.code,{children:"@automerge/automerge"})]}),"\n",(0,a.jsxs)(t.p,{children:["More recently we rewrote automerge in Rust and deployed it to javascript by compiling to a wasm package at ",(0,a.jsx)(t.a,{href:"https://www.npmjs.com/package/@automerge/automerge-wasm",children:(0,a.jsx)(t.code,{children:"@automerge/automerge-wasm"})}),". This wasm package is something we currently consider to be an implementation detail and should not be depended on by third parties. The ",(0,a.jsx)(t.code,{children:"@automerge/automerge"})," package offers a very similar API to the original ",(0,a.jsx)(t.code,{children:"automerge"})," package but implemented by forwarding logic to ",(0,a.jsx)(t.code,{children:"@automerge/automerge-wasm"}),". It is consequently much faster."]}),"\n",(0,a.jsx)(t.h3,{id:"automergeautomerge-repo",children:(0,a.jsx)(t.code,{children:"@automerge/automerge-repo"})}),"\n",(0,a.jsxs)(t.p,{children:["The core automerge libraries (both the original classic library and the WASM implementation) offer a compact storage format and a network agnostic sync protocol, but they don't actually do the work of wiring these things up to real storage engines (such as filesystems) or transports (such as websockets). ",(0,a.jsx)(t.code,{children:"automerge-repo"})," implements all of this plumbing and is how we recommend using automerge going forward."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);