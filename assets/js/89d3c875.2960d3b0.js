"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5216],{94:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"under-the-hood/rich_text_schema","title":"Rich Text Schema","description":"The rich text API provides a set of primitives for annotating a sequence of characters with formatting information. The two primitives in question are","source":"@site/docs/under-the-hood/rich_text_schema.md","sourceDirName":"under-the-hood","slug":"/under-the-hood/rich_text_schema","permalink":"/docs/under-the-hood/rich_text_schema","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/under-the-hood/rich_text_schema.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Merge Rules","permalink":"/docs/under-the-hood/merge_rules"},"next":{"title":"API Docs","permalink":"/docs/api"}}');var i=t(4848),s=t(8453);const o={sidebar_position:4},a="Rich Text Schema",l={},h=[{value:"Marks",id:"marks",level:2},{value:"Block Markers",id:"block-markers",level:2},{value:"<code>parents</code> - representing hierarchical structure",id:"parents---representing-hierarchical-structure",level:3},{value:"Embeds",id:"embeds",level:3},{value:"Putting It All Together",id:"putting-it-all-together",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rich-text-schema",children:"Rich Text Schema"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"../../documents/rich_text",children:"rich text"})," API provides a set of primitives for annotating a sequence of characters with formatting information. The two primitives in question are"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Marks - formatting spans which apply to a range of characters and can overlap"}),"\n",(0,i.jsx)(n.li,{children:"Block markers which divide the text into blocks"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["These primitives are flexible enough that there are a wide variety of ways to build an editor on top of them. This page documents the (extremely minimal) schema we use in the ",(0,i.jsx)(n.code,{children:"automerge-prosemirror"})," bindings and which we hope is general and useful enough that other editor bindings could adopt it. This is a work in progress and we hope others will build on and contribute to it."]}),"\n",(0,i.jsx)(n.p,{children:"The requirements we have for this schema are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The ability to represent inline text decoration such as bold spans, as well as semantic information like hyperlinks or code spans"}),"\n",(0,i.jsx)(n.li,{children:"A way of representing hierarchical structure which merges well - or, alternatively, which results in patches which are commensurate in size with the editing action the user took (inserting a paragraph is a single user action, we would like it to not result in a large patch which is hard to interpret)"}),"\n",(0,i.jsx)(n.li,{children:"A way for applications to extend the schema with their own specific mark and block types in such a way that there is still some degree of interoperability between applications"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"marks",children:"Marks"}),"\n",(0,i.jsx)(n.p,{children:"We define the following marks"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"strong"'})," - represents a span of bolded text, has value ",(0,i.jsx)(n.code,{children:"true"})," if present"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"em"'})," - represents a span of italicized text, has value ",(0,i.jsx)(n.code,{children:"true"})," if present"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"link"'})," - represents a span of text which links to a URL. The value is a string  representing the JSON serialization of the following object"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "href": "<the URL to link to>",\n    "title": "<a description of what the link points to>"\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Any other mark names are application specific and should be prefixed by a probably unique string that begins ",(0,i.jsx)(n.code,{children:'"__ext__"'}),". If an editor integration encounters a mark it does not recognise, the mark should be round tripped through the editor - I.e. if the users makes some change to the document via the editor integration, the mark should be left untouched."]}),"\n",(0,i.jsx)(n.h2,{id:"block-markers",children:"Block Markers"}),"\n",(0,i.jsx)(n.p,{children:"Blocks represent the hierarchical structure of the document. A block has the following type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"{\n    type: string,\n    parents: string[],\n    attrs: Record<string, any>,\n    isEmbed: boolean,\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["All text following a block marker until the next block marker or the end of the document belongs to the block marker - except in the case of an ",(0,i.jsx)(n.code,{children:"isEmbed: true"})," block, which will be described shortly."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"type"})," of the block determines how the block is rendered. We define the following block types:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"paragraph"'})," - a block of text"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"heading"'})," a heading. The ",(0,i.jsx)(n.code,{children:"attrs"})," object should contain a ",(0,i.jsx)(n.code,{children:"level"})," key which is a number from 1 to 6"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"code-block"'})," - a block of code. The ",(0,i.jsx)(n.code,{children:"attrs"})," object ",(0,i.jsx)(n.strong,{children:"MAY"})," have a ",(0,i.jsx)(n.code,{children:"language: string"})," key which hints at what language the block contains"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"blockquote"'})," - a block of quoted text"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"ordered-list-item"'})," - An item in an ordered list (i.e. a numbered list)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"unordered-list-item"'})," - An item in an unordered list (i.e. a bulleted list)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'"image"'})," - An image. The ",(0,i.jsx)(n.code,{children:"attrs"})," object should contain the following keys:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"{\n    src: string // the URL of the image,\n    alt: string | null // the alt text describing the content of the image,\n    title: string | null// the title of the image,\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An image block ",(0,i.jsx)(n.strong,{children:"SHOULD"})," have ",(0,i.jsx)(n.code,{children:"isEmbed: true"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Any other block types are application specific and should be prefixed by a probably unique string that begins ",(0,i.jsx)(n.code,{children:'"__ext__"'}),". If an editor integration encounters a block type it does not recognise the block should be rendered as a generic block element. Unrecognised attributes should be round tripped through the editor."]}),"\n",(0,i.jsxs)(n.h3,{id:"parents---representing-hierarchical-structure",children:[(0,i.jsx)(n.code,{children:"parents"})," - representing hierarchical structure"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"parents"})," array of a block represents the blocks which it appears inside. For example, a block like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n    type: "paragraph",\n    parents: ["blockquote"]\n    attrs: {},\n    isEmbed: false\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Represents a paragraph which is inside a blockquote. We call the ",(0,i.jsx)(n.code,{children:"path"})," of a block marker the array ",(0,i.jsx)(n.code,{children:"[...parents, type]"}),". The children of some block ",(0,i.jsx)(n.code,{children:"a"})," are all the blocks following that marker for which the path of ",(0,i.jsx)(n.code,{children:"a"})," is a proper prefix of the child block's path. Note that because a blocks contents are always after it and before it's next sibling, paths don't need to be unique - they only need to provide enough information to clearly match where in the hierarchy a block sits."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Sometimes a block will reference a parent that doesn't exist in the list. When that happens - that parent is implicitly created with the defaults expected for it's block type. This ensures you can't accidentally remove a block's container by deleting the containing block or one of the block's siblings, since each block contains a minimal copy of the hierarchy needed to properly place it."})}),"\n",(0,i.jsx)(n.p,{children:"For example, the following sequence of block marks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{ parents: ["blockquote"], type: "paragraph" }\n{ parents: ["blockquote", "ordered-list-item"], type: "paragraph" }\n{ parents: [], type: "paragraph" }\n'})}),"\n",(0,i.jsx)(n.p,{children:"Will result in the following hierarchy:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"blockquote:\n  - paragraph\n  - ordered-list-item:\n      - paragraph\nparagraph\n"})}),"\n",(0,i.jsx)(n.p,{children:'Note that the "blockquote" and "ordered-list-item" blocks are generated because they are parent\'s of the first two paragraphs, even though they aren\'t explicitly listed.'}),"\n",(0,i.jsx)(n.h3,{id:"embeds",children:"Embeds"}),"\n",(0,i.jsxs)(n.p,{children:["Blocks with ",(0,i.jsx)(n.code,{children:"isEmbed: true"})," are blocks which are not part of the flow of text and represent some non-textual content such as an image. Embed block markers should ",(0,i.jsx)(n.em,{children:"not"})," break up the flow of text. I.e. the text following an ",(0,i.jsx)(n.code,{children:"isEmbed: true"})," block marker belongs to the first non embed block preceding the embed block marker."]}),"\n",(0,i.jsxs)(n.p,{children:["If an application encounters an unknown embed block it should render the block using some sort of generic UI and round trip the block through the editor. The editor ",(0,i.jsx)(n.strong,{children:"SHOULD"})," allow the user to delete the embedded block marker in some manner."]}),"\n",(0,i.jsx)(n.h2,{id:"putting-it-all-together",children:"Putting It All Together"}),"\n",(0,i.jsxs)(n.p,{children:["When retrieving the current value of a rich text document via the ",(0,i.jsx)(n.a,{href:"../../documents/rich-text#The%20Spans%20API",children:"Spans API"}),", you will get an array of Spans with the following structure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'{\n    type: "block",\n    value: {\n        type: string,\n        parents: string[],\n        attrs: Record<string, any>,\n        isEmbed: boolean,\n    }\n} |\n{\n    type: "text",\n    value: string,\n    marks?: {\n        [markName: string]: boolean | string | number // remember that marks are primitive values, and are not merged.\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For example, I could take the following rich text document:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'[\n    {\n        type: "text", value: "From the automerge docs:"\n    },\n    {\n        type: "block",\n        value: { parents: ["blockquote"], type: "paragraph" },\n    },\n    { type: "text", value:  "The requirements we have for this schema are:" },\n    {\n        type: "block",\n        value: { parents: ["blockquote", "ordered-list"], type: "paragraph"},\n    },\n    {type: "text": value: "The ability to represent inline text decoration such as bold spans, as well as semantic information like hyperlinks or code spans"},\n    {\n        type: "block",\n        value: { parents: ["blockquote", "ordered-list"], type: "paragraph"},\n    },\n    {type: "text": value: "A way of representing hierarchical structure which merges well - or, alternatively, which results in patches which are commensurate in size with the editing action the user took (inserting a paragraph is a single user action, we would like it to not result in a large patch which is hard to interpret)"},\n    { type: "block", value: {parents: ["blockquote"], type: "paragraph"}},\n    {type: "text", value: "..."}\n    { type: "block", value: { parents: [], type: "paragraph"}},\n    {\n        type: "text", value: "From: ", marks: { strong: true }\n    },\n    {\n        type: "text", value: "Rich Text Schema", marks: { link: \'{"href": "/", title: ""}\', em: true}\n    }\n]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Which I could render like so:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"From the automerge docs"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The requirements we have for this schema are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The ability to represent inline text decoration such as bold spans, as well as semantic information like hyperlinks or code spans"}),"\n",(0,i.jsx)(n.li,{children:"A way of representing hierarchical structure which merges well - or, alternatively, which results in patches which are commensurate in size with the editing action the user took (inserting a paragraph is a single user action, we would like it to not result in a large patch which is hard to interpret)\n..."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"From:"})," ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"/",children:"Rich Text Schema"})})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);