"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8434],{6235:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/08/23/wasm-packaging","editUrl":"https://github.com/automerge/automerge.github.io/edit/main/blog/2024-08-23-wasm-packaging.md","source":"@site/blog/2024-08-23-wasm-packaging.md","title":"Automerge Anywhere","description":"One of Automerge\'s key strengths is its portability. The core of the CRDT is written in Rust, which allows us to bind it into a wide variety of languages including JavaScript, Swift, Kotlin, C, Go, and Python. In the browser, we compile the Rust code to WebAssembly to load it there.","date":"2024-08-23T00:00:00.000Z","tags":[],"readingTime":3.055,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Automerge Repo 2.0","permalink":"/blog/2025/05/13/automerge-repoo-2"},"nextItem":{"title":"Automerge 2.2: Rich Text","permalink":"/blog/2024/04/06/richtext"}}')},7786:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>u});var n=o(6235),i=o(4848),a=o(8453);const r={},s="Automerge Anywhere",l={authorsImageUrls:[]},u=[{value:"Anywhere?",id:"anywhere",level:2},{value:"How to use it",id:"how-to-use-it",level:2},{value:"For libraries which depend on automerge",id:"for-libraries-which-depend-on-automerge",level:3}];function m(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"One of Automerge's key strengths is its portability. The core of the CRDT is written in Rust, which allows us to bind it into a wide variety of languages including JavaScript, Swift, Kotlin, C, Go, and Python. In the browser, we compile the Rust code to WebAssembly to load it there."}),"\n",(0,i.jsx)(t.p,{children:"Unfortunately, native browser support for WebAssembly modules has remained quite a subtle art: different runtimes, package managers, bundlers, and browsers have all settled on different approaches and have different constraints. It's a real mess out there."}),"\n",(0,i.jsxs)(t.p,{children:["In the last few weeks, we returned to the problem of WASM packaging with some determination and some new ideas courtesy of ",(0,i.jsx)(t.a,{href:"https://nickb.dev/blog/recommendations-when-publishing-a-wasm-library/",children:"Nick Babrock"}),". The result is a set of new packaging options that should make loading Automerge possible anywhere, including quite a few places where it was difficult or impossible before."]}),"\n",(0,i.jsx)(t.h2,{id:"anywhere",children:"Anywhere?"}),"\n",(0,i.jsx)(t.p,{children:"If you're already using Automerge successfully in your environment, nothing will change. The new features are strictly additive. What we have done is introduce a few new ways to load Automerge by including the option for manual initialization of the WASM object and a base64 encoded string version as well."}),"\n",(0,i.jsx)(t.p,{children:"This means you should be able to conveniently use Automerge in vanilla JS applications with no bundler, in React-Native applications on mobile devices, within cloud services like Cloudflare Workers or on Val.town, and probably anywhere else you can think of."}),"\n",(0,i.jsxs)(t.p,{children:["If you find a place where none of our approaches work for you then please let us know by inquring ",(0,i.jsx)(t.a,{href:"https://discord.gg/TrgN9FkYSa",children:"in our Discord"})," or by filing a (GitHub issue)[",(0,i.jsx)(t.a,{href:"https://github.com/automerge/automerge",children:"https://github.com/automerge/automerge"}),"]."]}),"\n",(0,i.jsx)(t.h2,{id:"how-to-use-it",children:"How to use it"}),"\n",(0,i.jsxs)(t.p,{children:["We've collected of examples showing how to initialize automerge in specific environments in ",(0,i.jsx)(t.a,{href:"https://automerge.org/docs/library_initialization/",children:"a new documentation page"}),". If you had trouble with Automerge in your environment before, try again without changing anything first. This new release improved support for a few edge cases within the old API, so you might find everything just starts working on its own."]}),"\n",(0,i.jsx)(t.p,{children:"If you do need to use the new manual initialization code you'll need to to make a couple of small changes:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Import the ",(0,i.jsx)(t.code,{children:"/slim"})," variant of automerge and separately, the WebAssembly blob."]}),"\n",(0,i.jsxs)(t.li,{children:["Await the result of calling ",(0,i.jsx)(t.code,{children:"Automerge.initializeWasm(wasm)"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"For example, here's how to perform initialization in a Vite app without importing WebAssembly modules:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"import { next as Automerge } from '@automerge/automerge/slim'\nimport wasm from \"@automerge/automerge/automerge.wasm?url\"\n// note here the ?url suffix mean that the wasm is loaded as a URL\n\n// initializeWasm accepts a URL, Request, UInt8Array, or a WebAssembly.Module.\nawait Automerge.initializeWasm(wasm)\n\n// Now you can use Automerge\nlet doc = Automerge.init()\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This also applies for applications using ",(0,i.jsx)(t.code,{children:"automerge-repo"}),", in that case you would import ",(0,i.jsx)(t.code,{children:"@automerge/automerge-repo/slim"}),". Like so:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"import { Repo } from '@automerge/automerge-repo/slim'\nimport { next as Automerge } from '@automerge/automerge/slim'\nimport wasm from \"@automerge/automerge/wasm_blob.wasm?url\"\n\nawait Automerge.initializeWasm(wasm)\n\n// Now you can use the Repo\nlet repo = new Repo({..})\nlet handle = repo.create()\n"})}),"\n",(0,i.jsx)(t.p,{children:"If you can't even load a binary file, we've even included a base64 encoded version of the WASM blob. This will be somewhat slower and large than a binary object but it's available as the ultimate fallback and you can use it like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'import { automergeWasmBase64 } from "@automerge/automerge/automerge.wasm.base64.js";\n// Note the `/slim` suffixes\nimport { next as Automerge } from "@automerge/automerge/slim";\nimport { Repo } from `@automerge/automerge-repo/slim`;\n\nawait next.initializeBase64Wasm(automergeWasmBase64)\n\n// Now we can get on with our lives\nconst repo = new Repo({..})\n'})}),"\n",(0,i.jsx)(t.h3,{id:"for-libraries-which-depend-on-automerge",children:"For libraries which depend on automerge"}),"\n",(0,i.jsxs)(t.p,{children:["If you are writing a library which depends on automerge that other applications might use, please be sure to only import the ",(0,i.jsx)(t.code,{children:"@automerge/automerge/slim"})," package. Doing so will ensure other users retain the option of"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>s});var n=o(6540);const i={},a=n.createContext(i);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);