"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1086],{1934:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"tutorial/multiple-task-lists","title":"Multiple Task Lists","description":"You might have noticed that if you lose the URL of a task list, it\'s gone forever. This is fine for testing and demos, but obviously no good for a real application.","source":"@site/docs/tutorial/07-multiple-task-lists.mdx","sourceDirName":"tutorial","slug":"/tutorial/multiple-task-lists","permalink":"/docs/tutorial/multiple-task-lists","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/tutorial/07-multiple-task-lists.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Multiple Task Lists"},"sidebar":"tutorialSidebar","previous":{"title":"Network Sync","permalink":"/docs/tutorial/network-sync"},"next":{"title":"Persisting the Root Document","permalink":"/docs/tutorial/persist-root-doc"}}');var s=n(6070),i=n(4331),c=(n(9821),n(6423)),r=n(8628);const l={title:"Multiple Task Lists"},a=void 0,d={},h=[{value:"Create a root document",id:"create-a-root-document",level:2},{value:"Multiple Task List UI",id:"multiple-task-list-ui",level:2},{value:"Creating a new Task List",id:"creating-a-new-task-list",level:2},{value:"Adding focus management to the sidebar",id:"adding-focus-management-to-the-sidebar",level:3},{value:"Creating new task lists",id:"creating-new-task-lists",level:3},{value:"URL Management",id:"url-management",level:2},{value:"Checking it works",id:"checking-it-works",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Keeping Track Of the Root Document",id:"keeping-track-of-the-root-document",level:2},{value:"Using the Root Document",id:"using-the-root-document",level:2},{value:"Registering Documents",id:"registering-documents",level:2}];function u(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"You might have noticed that if you lose the URL of a task list, it's gone forever. This is fine for testing and demos, but obviously no good for a real application."}),"\n",(0,s.jsxs)(t.p,{children:["Automerge is built around the document as a building block for your application, and we use ",(0,s.jsx)(t.code,{children:"AutomergeUrl"})," links to connect those ocuments together. We've already created one kind of document, a task list, and now we're going to build on that foundation by collecting your task lists into something like a folder to keep them organized."]}),"\n",(0,s.jsx)(t.p,{children:'This is going to give us a chance to see a few patterns in action: linking between documents with URLs, working with multiple documents at once, and using a single document as the "entry point" for your application.'}),"\n",(0,s.jsx)(t.p,{children:'You can think of the "entry point" as being akin to a user\'s account. By synchronizing that document between their devices, a user can get access to their documents from multiple browsers or devices, but be careful: until we implement some kind of security on the sync server, a user\'s privacy relies on their not sharing that "root" document ID with anyone else.'}),"\n",(0,s.jsx)(t.p,{children:"Here's the plan. We are going to:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:'Create a new "root" document which links to all the task lists the user has opened.'}),"\n",(0,s.jsx)(t.li,{children:"Create some UI to handle switching between several different task lists"}),"\n",(0,s.jsx)(t.li,{children:"Register task lists we open or create in that root document (if we don't have them already.)"}),"\n",(0,s.jsx)(t.li,{children:"Store the root document's ID in localStorage in a well-known key to check during startup."}),"\n",(0,s.jsx)(t.li,{children:'Create a simple UI for copying the root document between browsers, creating rudimentary "accounts".'}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If this feels different to you from how a traditional database works, that's normal. With Automerge, building an application will eel more like linking together a web of documents than querying a database."}),"\n",(0,s.jsx)(t.h2,{id:"create-a-root-document",children:"Create a root document"}),"\n",(0,s.jsxs)(t.p,{children:["Our root document is going to track all the task lists the user has created or opened. Let's add a type for it in ",(0,s.jsx)(t.code,{children:"src/rootDoc.ts"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",metastring:'file="src/rootDoc.ts"',children:"type RootDocument = {\n  taskLists: AutomergeUrl[];\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["It's just a list of ",(0,s.jsx)(t.code,{children:"AutomergeUrl"}),"s, each of which points to a document containing a task list."]}),"\n",(0,s.jsx)(t.p,{children:"Intially we'll create a new root document on every page load and we'll put the URL of the current task list in that root document. This will allow us to focus on the UI work but then we'll come back and add the logic to persist the root document."}),"\n",(0,s.jsxs)(t.p,{children:["Add this code to ",(0,s.jsx)(t.code,{children:"src/main.tsx"})," to create the root document:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'// highlight-next-line\nimport { RootDocument } from "./rootDoc.ts"\n// ..\n\n// Add the repo to the global window object so it can be accessed in the browser console\n// This is useful for debugging and testing purposes.\ndeclare global {\n  interface Window {\n    repo: Repo;\n    // We also add the handle to the global window object for debugging\n    // highlight-next-line\n    handle: DocHandle<RootDocument>;\n  }\n}\nwindow.repo = repo;\n\n// Check the URL for a document to load\nconst locationHash = document.location.hash.substring(1);\n// Depending if we have an AutomergeUrl, either find or create the document\nif (isValidAutomergeUrl(locationHash)) {\n  // highlight-start\n  const taskList = await repo.find(locationHash);\n  window.handle = repo.create({ taskLists: [taskList.url] });\n  // highlight-end\n} else {\n  // highlight-start\n  const taskList = repo.create<TaskList>(initTaskList());\n  window.handle = repo.create({ taskLists: [taskList.url] });\n  // Set the location hash to the new document we just made.\n  document.location.hash = taskList.url;\n  // highlight-end\n}\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    <Suspense fallback={<div>Loading a document...</div>}>\n      <RepoContext.Provider value={repo}>\n        <App docUrl={window.handle.url} />\n      </RepoContext.Provider>\n    </Suspense>\n  </React.StrictMode>,\n);\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Now, we're passing the URL of the root document to the ",(0,s.jsx)(t.code,{children:"App"})," component, but the ",(0,s.jsx)(t.code,{children:"App"})," component is still expecting a ",(0,s.jsx)(t.code,{children:"TaskList"})," document, not a ",(0,s.jsx)(t.code,{children:"RootDocument"}),". Let's fix that, add this code to the ",(0,s.jsx)(t.code,{children:"App"})," component."]}),"\n",(0,s.jsx)(t.p,{children:"Now, if you open the application the behavior shouldn't change, but you can check the root document in the browser console:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"console.log(window.handle.doc())\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This should display a document with a ",(0,s.jsx)(t.code,{children:"taskLists"})," array containing the URL of the task list you just created or opened."]}),"\n",(0,s.jsx)(t.h2,{id:"multiple-task-list-ui",children:"Multiple Task List UI"}),"\n",(0,s.jsx)(t.p,{children:"Now that we have a root document that can manage multiple task lists, we need some UI to allow us to select from those task lists. We're going to add a very simple sidebar which lists all the task lists you have access to. We'll start with a simple list of the task lists you have available, then we'll add features for selecting and creating new task lists."}),"\n",(0,s.jsxs)(t.p,{children:["Add the following code to ",(0,s.jsx)(t.code,{children:"src/components/DocumentList.tsx"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/components/DocumentList.tsx"',children:'import React from "react";\nimport { useDocument, AutomergeUrl } from "@automerge/react";\nimport { TaskList } from "./TaskList";\n\nexport interface DocumentList {\n  taskLists: AutomergeUrl[];\n}\n\nexport const DocumentList: React.FC<{\n  docUrl: AutomergeUrl;\n}> = ({ docUrl }) => {\n  const [doc, changeDoc] = useDocument<DocumentList>(docUrl, {\n    suspense: true,\n  });\n\n  return (\n    <div className="document-list">\n      <div className="documents">\n        {doc.taskLists.map((docUrl) => (\n          <div key={docUrl} className={`document-item`}>\n            <DocumentTitle docUrl={docUrl} />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\n// Component to display document title\nconst DocumentTitle: React.FC<{ docUrl: AutomergeUrl }> = ({ docUrl }) => {\n  const [doc] = useDocument<TaskList>(docUrl, { suspense: true });\n\n  // Get the first task\'s title or use a default\n  const title = doc.title || "Untitled Task List";\n  return <div>{title}</div>;\n};\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Then render the ",(0,s.jsx)(t.code,{children:"DocumentList"})," in ",(0,s.jsx)(t.code,{children:"App.tsx"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/components/App.tsx"',children:'// ..\n// highlight-next-line\nimport { DocumentList } from "./DocumentList";\n// ..\n\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  const [doc] = useDocument<RootDocument>(docUrl, {\n    suspense: true,\n  });\n\n  return (\n    <>\n      <header>\n        <h1>\n          <img src={automergeLogo} alt="Automerge logo" id="automerge-logo" />\n          Automerge Task List\n        </h1>\n      </header>\n\n      <main>\n        // highlight-start\n        <div className="document-list">\n          <DocumentList docUrl={docUrl} />\n        </div>\n        // highlight-end\n        <div className="task-list">\n          <TaskList docUrl={doc.taskLists[0]} />\n        </div>\n      </main>\n\n      <footer>\n        <p className="footer-copy">\n          Powered by Automerge + Vite + React + TypeScript\n        </p>\n      </footer>\n    </>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Loading up the task list should now show something like this:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"An image of the web app showing a sidebar listing task lists",src:n(7026).A+"",width:"966",height:"521"})}),"\n",(0,s.jsx)(t.p,{children:"Here you can see there is now a very basic sidebar to the left of the todo list showing the available task lists."}),"\n",(0,s.jsx)(t.h2,{id:"creating-a-new-task-list",children:"Creating a new Task List"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we can track task lists we need a way to create a new one. We'll add a button to the sidebar that allows us to create a new task list. This isn't useful on it's own though, we also need some way of signalling to the app that we want to change focus to the new task list. We'll do this by adding two properties to the sidebar, a ",(0,s.jsx)(t.code,{children:"selectedDocument"})," property which sets the focus for the task list, and an ",(0,s.jsx)(t.code,{children:"onSelectDocument"})," callback which the sidebar uses to notify the app when a new task list is selected."]}),"\n",(0,s.jsx)(t.p,{children:"We can split this process into two phases, first we'll add the focus management to the sidebar, then we'll add the button to create a new task list."}),"\n",(0,s.jsx)(t.h3,{id:"adding-focus-management-to-the-sidebar",children:"Adding focus management to the sidebar"}),"\n",(0,s.jsx)(t.p,{children:"Here's what we need to do:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Add ",(0,s.jsx)(t.code,{children:"selectedDocument"})," and ",(0,s.jsx)(t.code,{children:"onSelectDocument"})," props to the ",(0,s.jsx)(t.code,{children:"DocumentList"})," component"]}),"\n",(0,s.jsxs)(t.li,{children:["Wire up the ",(0,s.jsx)(t.code,{children:"selectedDocument"})," state to the ",(0,s.jsx)(t.code,{children:"DocumentTitle"})," component so that clicking on a document title will select it"]}),"\n",(0,s.jsxs)(t.li,{children:["Modify the ",(0,s.jsx)(t.code,{children:"App"})," component to track the currently selected document URL and pass it to the ",(0,s.jsx)(t.code,{children:"TaskList"})," component"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Add the following code to ",(0,s.jsx)(t.code,{children:"src/components/DocumentList.tsx"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/components/DocumentList.tsx"',children:'import React from "react";\nimport { useDocument, AutomergeUrl } from "@automerge/react";\nimport { TaskList } from "./TaskList";\n\nimport { RootDocument } from "../rootDoc";\n\nexport const DocumentList: React.FC<{\n  docUrl: AutomergeUrl;\n  // highlight-start\n  selectedDocument: AutomergeUrl | null;\n  onSelectDocument: (docUrl: AutomergeUrl | null) => void;\n}> = ({ docUrl, selectedDocument, onSelectDocument }) => {\n  // highlight-end\n  const [doc] = useDocument<RootDocument>(docUrl, {\n    suspense: true,\n  });\n\n  return (\n    <div className="document-list">\n      <div className="documents">\n        {doc.taskLists.map((docUrl) => (\n          <div\n            key={docUrl}\n            // highlight-start\n            className={`document-item ${docUrl === selectedDocument ? "active" : ""}`}\n            onClick={() => onSelectDocument(docUrl)}\n            // highlight-end\n          >\n            <DocumentTitle docUrl={docUrl} />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\n// Component to display document title\nconst DocumentTitle: React.FC<{ docUrl: AutomergeUrl }> = ({ docUrl }) => {\n  const [doc] = useDocument<TaskList>(docUrl, { suspense: true });\n\n  // Get the first task\'s title or use a default\n  const title = doc.title || "Untitled Task List";\n  return <div>{title}</div>;\n};\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Add the following code to ",(0,s.jsx)(t.code,{children:"src/components/App.tsx"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/components/App.tsx"',children:'// ..\n// highlight-next-line\nimport { useState } from "react";\n\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  const [doc] = useDocument<RootDocument>(docUrl, {\n    suspense: true,\n  });\n  // highlight-start\n  const [selectedDocUrl, setSelectedDocUrl] = useState<AutomergeUrl | null>(\n    null,\n  );\n  // highlight-end\n\n  return (\n    <>\n      <header>\n        <h1>\n          <img src={automergeLogo} alt="Automerge logo" id="automerge-logo" />\n          Automerge Task List\n        </h1>\n      </header>\n\n      <main>\n        <div className="document-list">\n          // highlight-start\n          <DocumentList\n            docUrl={docUrl}\n            onSelectDocument={setSelectedDocUrl}\n            selectedDocument={selectedDocUrl}\n          />\n          // highlight-end\n        </div>\n        <div className="task-list">\n          // higlight-next-line\n          {selectedDocUrl ? <TaskList docUrl={selectedDocUrl} /> : null}\n        </div>\n      </main>\n\n      <footer>\n        <p className="footer-copy">\n          Powered by Automerge + Vite + React + TypeScript\n        </p>\n      </footer>\n    </>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now when you initially load the app, the main task list will be empty, but you can click on the sidebar to select a task list. The selected task list will be highlighted in the sidebar."}),"\n",(0,s.jsx)(t.h3,{id:"creating-new-task-lists",children:"Creating new task lists"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we can manage which task list is focused in the sidebar we can wire up task list creation. We'll add a button to the sidebar that allows us to create a new task list, and when clicked it will create a new task list document, register it in the root document, and fire the ",(0,s.jsx)(t.code,{children:"onSelectDocument"})," callback to switch focus to the new task list."]}),"\n",(0,s.jsxs)(t.p,{children:["To create a new document from within a component we use the ",(0,s.jsx)(t.code,{children:"useRepo"})," hook. This gives us access to the ",(0,s.jsx)(t.code,{children:"Repo"})," which we can then call ",(0,s.jsx)(t.code,{children:"Repo.find"})," on to create a new document for the new task list. Finally, we will add the new task list to the root document and fire the ",(0,s.jsx)(t.code,{children:"onSelectDocument"})," callback to switch focus to the new task list."]}),"\n",(0,s.jsxs)(t.p,{children:["Add this code to the ",(0,s.jsx)(t.code,{children:"DocumentList"})," component in ",(0,s.jsx)(t.code,{children:"src/components/DocumentList.tsx"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/components/DocumentList.tsx"',children:'import React from "react";\n// highlight-next-line\nimport { useDocument, AutomergeUrl, useRepo } from "@automerge/react";\n// highlight-next-line\nimport { initTaskList, TaskList } from "./TaskList";\n\nimport { RootDocument } from "../rootDoc";\n\nexport const DocumentList: React.FC<{\n  docUrl: AutomergeUrl;\n  selectedDocument: AutomergeUrl | null;\n  onSelectDocument: (docUrl: AutomergeUrl | null) => void;\n}> = ({ docUrl, selectedDocument, onSelectDocument }) => {\n  // highlight-next-line\n  const repo = useRepo();\n  const [doc, changeDoc] = useDocument<RootDocument>(docUrl, {\n    suspense: true,\n  });\n\n  // highlight-start\n  const handleNewDocument = () => {\n    const newTaskList = repo.create<TaskList>(initTaskList());\n    changeDoc((d) => d.taskLists.push(newTaskList.url));\n    onSelectDocument(newTaskList.url);\n  };\n  // highlight-end\n\n  return (\n    <div className="document-list">\n      <div className="documents">\n        {doc.taskLists.map((docUrl) => (\n          <div\n            key={docUrl}\n            className={`document-item ${docUrl === selectedDocument ? "active" : ""}`}\n            onClick={() => onSelectDocument(docUrl)}\n          >\n            <DocumentTitle docUrl={docUrl} />\n          </div>\n        ))}\n      </div>\n      // highlight-next-line\n      <button onClick={handleNewDocument}>+ Task List</button>\n    </div>\n  );\n};\n\n// Component to display document title\nconst DocumentTitle: React.FC<{ docUrl: AutomergeUrl }> = ({ docUrl }) => {\n  const [doc] = useDocument<TaskList>(docUrl, { suspense: true });\n\n  // Get the first task\'s title or use a default\n  const title = doc.title || "Untitled Task List";\n  return <div>{title}</div>;\n};\n'})}),"\n",(0,s.jsx)(t.p,{children:'Now if you load up the app you\'ll see a "+ Task List" button in the sidebar. Clicking this will create a new task list document, register it in the root document, and switch focus to the new task list.'}),"\n",(0,s.jsx)(t.h2,{id:"url-management",children:"URL Management"}),"\n",(0,s.jsx)(t.p,{children:"This has all worked very well, but before we finish this section there's one deficiency we should address. The URL in the browser location hash does not update when we switch task list selection. This means that when we create a new task list, there's no way to share it with others. To fix this, we're going to slightly change how we handle the browser location hash."}),"\n",(0,s.jsxs)(t.p,{children:["At the moment, we look up the document URL from the location hash on boot, then we never change it. Now, we are going to manage the location hash as part of the application. To do this we will push responsibility for the URL hash management into the ",(0,s.jsx)(t.code,{children:"App"})," component. This will allow us to update the URL hash whenever we switch task lists, making it easier to share task lists with others."]}),"\n",(0,s.jsx)(t.p,{children:"Here's how we'll do it:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"First, update the initialization logic to create an empty root document if it doesn't exist"}),"\n",(0,s.jsxs)(t.li,{children:["Add hash management to the ",(0,s.jsx)(t.code,{children:"App"})," component using the ",(0,s.jsx)(t.code,{children:"useHash"})," function from ",(0,s.jsx)(t.a,{href:"https://www.npmjs.com/package/react-use",children:(0,s.jsx)(t.code,{children:"react-use"})})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["First, let's update our initialization logic. Remove the lines highlighted in red in the following code snippet, and replace them with the single line ",(0,s.jsx)(t.code,{children:"window.handle = repo.create({ taskLists: []})"})," that follows."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",metastring:'title="src/main.tsx"',children:"// ..\n\n// highlight-red-start\n// Depending if we have an AutomergeUrl, either find or create the document\nif (isValidAutomergeUrl(locationHash)) {\n  const taskList = await repo.find(locationHash);\n  window.handle = repo.create({ taskLists: [taskList.url] });\n} else {\n  const taskList = repo.create<TaskList>(initTaskList());\n  window.handle = repo.create({ taskLists: [taskList.url] });\n  // Set the location hash to the new document we just made.\n  document.location.hash = taskList.url;\n}\n// highlight-red-end\nwindow.handle = repo.create({ taskLists: [] });\n\n// ..\n"})}),"\n",(0,s.jsx)(t.p,{children:"At this point, loading the application will give you no selected task list at all and creating new task lists via the sidebar will populate the UI but not update the URL hash."}),"\n",(0,s.jsxs)(t.p,{children:["Let's add URL hash management to the ",(0,s.jsx)(t.code,{children:"App"})," component. First, install the ",(0,s.jsx)(t.code,{children:"react-use"})," package:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"npm install react-use\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then, update the ",(0,s.jsx)(t.code,{children:"App"})," component to use the ",(0,s.jsx)(t.code,{children:"useHash"})," hook:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",metastring:'title="src/components/App.tsx"',children:'// ..\n// highlight-next-line\nimport { useHash } from "react-use";\n\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  // highlight-start\n  const [hash, setHash] = useHash();\n  const cleanHash = hash.slice(1); // Remove the leading \'#\'\n  const selectedDocUrl =\n    cleanHash && isValidAutomergeUrl(cleanHash)\n      ? (cleanHash as AutomergeUrl)\n      : null;\n  // highlight-end\n\n  return (\n    <>\n      <header>\n        <h1>\n          <img src={automergeLogo} alt="Automerge logo" id="automerge-logo" />\n          Automerge Task List\n        </h1>\n      </header>\n\n      <main>\n        <div className="document-list">\n          <DocumentList\n            docUrl={docUrl}\n            // highlight-start\n            onSelectDocument={(url) => {\n              if (url) {\n                setHash(url);\n              } else {\n                setHash("");\n              }\n            }}\n            // highlight-end\n            selectedDocument={selectedDocUrl}\n          />\n        </div>\n        <div className="task-list">\n          {selectedDocUrl ? <TaskList docUrl={selectedDocUrl} /> : null}\n        </div>\n      </main>\n\n      <footer>\n        <p className="footer-copy">\n          Powered by Automerge + Vite + React + TypeScript\n        </p>\n      </footer>\n    </>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(t.p,{children:"This is almost there. Loading the app now you'll see that creating new task lists and selecting them in the sidebar updates the URL hash. There is one thing missing though. If you create a new task list, then copy the URL and load it in a new tab, the task list will appear in the main view, but the sidebar will be empty. This is because the sidebar only shows task lists that are registered in the root document, and updating the URL hash does not cause the root document to be updated."}),"\n",(0,s.jsxs)(t.p,{children:["We'll fix this in the ",(0,s.jsx)(t.code,{children:"DocumentList"})," as this is the component responsible for managing the list of task lists. We need to ensure that when a new task list is created or looked up, it is also registered in the root document. Update ",(0,s.jsx)(t.code,{children:"DocumentList.tsx"})," to include the registration logic:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",metastring:'title="src/components/DocumentList.tsx"',children:'// ..\n/\n// highlight-next-line\nimport { useEffect } from "react";\n\nexport const DocumentList: React.FC<{\n  docUrl: AutomergeUrl;\n  selectedDocument: AutomergeUrl | null;\n  onSelectDocument: (docUrl: AutomergeUrl | null) => void;\n}> = ({ docUrl, selectedDocument, onSelectDocument }) => {\n  const repo = useRepo();\n  const [doc, changeDoc] = useDocument<RootDocument>(docUrl, {\n    suspense: true,\n  });\n\n  // highlight-start\n  useEffect(() => {\n    changeDoc((d) => {\n      if (selectedDocument && !d.taskLists.includes(selectedDocument)) {\n        // If the selected document is not in the list, add it\n        d.taskLists.push(selectedDocument);\n      }\n    });\n  }, [selectedDocument, changeDoc]);\n  // highlight-end\n\n  const handleNewDocument = () => {\n    const newTaskList = repo.create<TaskList>(initTaskList());\n    changeDoc((d) => d.taskLists.push(newTaskList.url));\n    onSelectDocument(newTaskList.url);\n  };\n\n  return (\n    // ..\n  );\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"checking-it-works",children:"Checking it works"}),"\n",(0,s.jsx)(t.p,{children:"Now, you should be able to load the application, create a new task list and see the URL hash update. If you copy the URL into a new window it should load the task list and show it in the main view, with the sidebar populated with the task list you just created."}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(t.p,{children:"We're keeping track of our tasks lists in the root document, but every time we refresh we still lose the whole root document. In the next section we'll persist the root document so that it survives page reloads and browser restarts. This will allow us to keep track of all the task lists we've created, even if we close the browser or switch devices."}),"\n",(0,s.jsx)(t.h2,{id:"keeping-track-of-the-root-document",children:"Keeping Track Of the Root Document"}),"\n",(0,s.jsxs)(t.p,{children:["Right now, the only place we store a document URL is in the browser location hash. This won't work for a root document, we need to keep track of the root document URL somewhere persistent. To that end, we're going to store the root document URL in local storage. This root document URL is the only data we will store outside of our ",(0,s.jsx)(t.code,{children:"Repo"}),", everything else will come from Automerge itself."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's create a new file ",(0,s.jsx)(t.code,{children:"src/rootDoc.ts"})," to handle the root document management:"]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(t.p,{children:"Create the root document management functions:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",metastring:'file="src/rootDoc.ts"',children:'import { AutomergeUrl, Repo } from "@automerge/react";\n\nconst ROOT_DOC_URL_KEY = "root-doc-url";\n\nexport interface DocumentList {\n  documents: AutomergeUrl[];\n}\n\nexport const getOrCreateRoot = (repo: Repo): AutomergeUrl => {\n  // Check if we already have a root document\n  const existingUrl = localStorage.getItem(ROOT_DOC_URL_KEY);\n  if (existingUrl) {\n    return existingUrl as AutomergeUrl;\n  }\n\n  // Otherwise create one and (synchronously) store it\n  const root = repo.create({ taskLists: [] });\n  localStorage.setItem(ROOT_DOC_URL_KEY, root.url);\n  return root.url;\n};\n'})})]}),"\n",(0,s.jsxs)(r.A,{children:[(0,s.jsx)(t.p,{children:"This code:"}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Defines the ",(0,s.jsx)(t.code,{children:"RootDocument"})," interface with a list of document URLs, each of which is a link to a task list"]}),"\n",(0,s.jsxs)(t.li,{children:["Uses ",(0,s.jsx)(t.code,{children:"localStorage"})," to persist the root document ID"]}),"\n",(0,s.jsx)(t.li,{children:"Provides a function to get/create the root document"}),"\n"]})]}),"\n",(0,s.jsx)(t.h2,{id:"using-the-root-document",children:"Using the Root Document"}),"\n",(0,s.jsx)(t.p,{children:"Let's update our main app to use the root document:"}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsxs)(t.p,{children:["Update ",(0,s.jsx)(t.code,{children:"src/main.tsx"})," to initialize the root document:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import React, { Suspense } from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./components/App.tsx";\nimport "./index.css";\n\nimport {\n  Repo,\n  BroadcastChannelNetworkAdapter,\n  WebSocketClientAdapter,\n  IndexedDBStorageAdapter,\n  RepoContext,\n  DocHandle,\n} from "@automerge/react";\n// highlight-next-line\nimport { getOrCreateRoot, RootDocument } from "./rootDoc.ts";\n\nconst repo = new Repo({\n  network: [\n    new BroadcastChannelNetworkAdapter(),\n    new WebSocketClientAdapter("wss://sync.automerge.org"),\n  ],\n  storage: new IndexedDBStorageAdapter(),\n});\n\n// Add the repo to the global window object so it can be accessed in the browser console\n// This is useful for debugging and testing purposes.\ndeclare global {\n  interface Window {\n    repo: Repo;\n    // We also add the handle to the global window object for debugging\n    handle: DocHandle<RootDocument>;\n  }\n}\nwindow.repo = repo;\n\n// highlight-begin\nconst rootDocUrl = getOrCreateRoot(repo);\nwindow.handle = await repo.find(rootDocUrl);\n// highlight-end\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    <Suspense fallback={<div>Loading a document...</div>}>\n      <RepoContext.Provider value={repo}>\n        <App docUrl={window.handle.url} />\n      </RepoContext.Provider>\n    </Suspense>\n  </React.StrictMode>,\n);\n'})}),(0,s.jsx)(t.p,{children:"Note that we no longer pull a document from the location hash, but instead load it out of local storage."}),(0,s.jsxs)(t.p,{children:["At this point you will get an error when loading the application because the URL we are passing to the ",(0,s.jsx)(t.code,{children:"App"})," component now contains a ",(0,s.jsx)(t.code,{children:"RootDocument"})," rather than the ",(0,s.jsx)(t.code,{children:"TaskList"})," which the ",(0,s.jsx)(t.code,{children:"App"})," component expects. We'll fix that in a moment, but you can still validate that the root doc code is working so far:"]}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:'Open your browser\'s developer tools (F12 or right-click and select "Inspect")'}),"\n",(0,s.jsx)(t.li,{children:'Go to the "Application" tab'}),"\n",(0,s.jsx)(t.li,{children:'In the left sidebar, under "Storage", click on "Local Storage"'}),"\n",(0,s.jsxs)(t.li,{children:["Look for the ",(0,s.jsx)(t.code,{children:"root-doc-url"})," key - it should contain a URL starting with ",(0,s.jsx)(t.code,{children:"automerge:"})]}),"\n",(0,s.jsx)(t.li,{children:"Then, run this code in the developer console"}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const rootDocUrl = localStorage.getItem("root-doc-id")\nconst root = window.repo.find(rootUrl);\nconsole.log("Root document:", root.doc());\n'})}),(0,s.jsxs)(t.p,{children:["You should see a console log showing the root document with an empty ",(0,s.jsx)(t.code,{children:"taskLists"})," array."]})]}),"\n",(0,s.jsx)(t.h2,{id:"registering-documents",children:"Registering Documents"}),"\n",(0,s.jsx)(t.p,{children:"Now that we have our root document set up, let's create a function to register new documents in it. This will be used whenever we create or open a document:"}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsxs)(t.p,{children:["Add a function to register documents in ",(0,s.jsx)(t.code,{children:"src/root.ts"}),":"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"export const registerDocument = (\n  repo: Repo,\n  rootId: AutomergeUrl,\n  docId: AutomergeUrl\n) => {\n  const root = repo.find(rootId);\n  root.change((doc: RootDocument) => {\n    if (!doc.documents.includes(docId)) {\n      doc.documents.push(docId);\n    }\n  });\n};\n"})}),(0,s.jsxs)(t.p,{children:["Let's wire this up in our main app. First, create a new file ",(0,s.jsx)(t.code,{children:"src/App.tsx"}),":"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import React, { useState } from "react";\nimport { useRepo } from "@automerge/automerge-repo-react-hooks";\nimport { registerDocument } from "./root";\n\nexport const App: React.FC<{\n  rootId: AutomergeUrl;\n}> = ({ rootId }) => {\n  const repo = useRepo();\n  const [selectedDocId, setSelectedDocId] = useState<AutomergeUrl | null>(null);\n\n  const handleCreateDocument = () => {\n    // Create a new task list document\n    const doc = repo.create({ tasks: [] });\n    // Register it in the root document\n    registerDocument(repo, rootId, doc.url);\n    // Select the new document\n    setSelectedDocId(doc.url);\n  };\n\n  return (\n    <div className="app">\n      <div className="sidebar">\n        <button onClick={handleCreateDocument}>New Task List</button>\n      </div>\n      <div className="main">\n        {selectedDocId ? (\n          <div>Selected document: {selectedDocId}</div>\n        ) : (\n          <div>Click "New Task List" to create a document</div>\n        )}\n      </div>\n    </div>\n  );\n};\n'})}),(0,s.jsx)(t.p,{children:"To test this:"}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:'Click the "New Task List" button'}),"\n",(0,s.jsx)(t.li,{children:"Open the browser console"}),"\n",(0,s.jsx)(t.li,{children:"Write this code to check the root document:"}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'const root = window.repo.find(localStorage.getItem("root-doc-url"));\nconsole.log("Root document:", root);\n'})}),(0,s.jsxs)(t.p,{children:["You should see the root document now contains the task list's URL in its ",(0,s.jsx)(t.code,{children:"documents"})," array."]})]}),"\n",(0,s.jsx)(t.p,{children:"Now we have the foundation for our document management system. The root document serves as your personal storage space, keeping track of all documents you've opened. This makes it easy to find and access your documents again, even after closing the browser or switching devices."}),"\n",(0,s.jsx)(t.p,{children:"Next, we're going to start actually using it by recording the documents we open into it."})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},4331:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>r});var o=n(758);const s={},i=o.createContext(s);function c(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(i.Provider,{value:t},e.children)}},6423:(e,t,n)=>{n.d(t,{A:()=>s});n(758);var o=n(6070);function s(e){let{children:t}=e;return(0,o.jsxs)("div",{className:"exercise",children:[(0,o.jsx)("div",{className:"exercise-header",children:(0,o.jsx)("h3",{children:"Exercise"})}),(0,o.jsx)("div",{className:"exercise-content",children:t})]})}},7026:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/document-list-79a07c2550a45113f18363e0ae970787.png"},8628:(e,t,n)=>{n.d(t,{A:()=>s});n(758);var o=n(6070);function s(e){let{children:t}=e;return(0,o.jsxs)("div",{className:"solution",children:[(0,o.jsx)("div",{className:"solution-header",children:(0,o.jsx)("h4",{children:"Solution"})}),(0,o.jsx)("div",{className:"solution-content",children:t})]})}},9821:(e,t,n)=>{n.d(t,{A:()=>S});var o=n(758),s=n(6070);function i(e){const{mdxAdmonitionTitle:t,rest:n}=function(e){const t=o.Children.toArray(e),n=t.find((e=>o.isValidElement(e)&&"mdxAdmonitionTitle"===e.type)),i=t.filter((e=>e!==n)),c=n?.props.children;return{mdxAdmonitionTitle:c,rest:i.length>0?(0,s.jsx)(s.Fragment,{children:i}):null}}(e.children),i=e.title??t;return{...e,...i&&{title:i},children:n}}var c=n(3526),r=n(1311),l=n(7967);const a="admonition_BudP",d="admonitionHeading_3rRN",h="admonitionIcon_GUtA",u="admonitionContent_Y5R8";function m(e){let{type:t,className:n,children:o}=e;return(0,s.jsx)("div",{className:(0,c.A)(l.G.common.admonition,l.G.common.admonitionType(t),a,n),children:o})}function p(e){let{icon:t,title:n}=e;return(0,s.jsxs)("div",{className:d,children:[(0,s.jsx)("span",{className:h,children:t}),n]})}function g(e){let{children:t}=e;return t?(0,s.jsx)("div",{className:u,children:t}):null}function x(e){const{type:t,icon:n,title:o,children:i,className:c}=e;return(0,s.jsxs)(m,{type:t,className:c,children:[o||n?(0,s.jsx)(p,{title:o,icon:n}):null,(0,s.jsx)(g,{children:i})]})}function w(e){return(0,s.jsx)("svg",{viewBox:"0 0 14 16",...e,children:(0,s.jsx)("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})})}const f={icon:(0,s.jsx)(w,{}),title:(0,s.jsx)(r.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)",children:"note"})};function j(e){return(0,s.jsx)(x,{...f,...e,className:(0,c.A)("alert alert--secondary",e.className),children:e.children})}function k(e){return(0,s.jsx)("svg",{viewBox:"0 0 12 16",...e,children:(0,s.jsx)("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})})}const v={icon:(0,s.jsx)(k,{}),title:(0,s.jsx)(r.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)",children:"tip"})};function U(e){return(0,s.jsx)(x,{...v,...e,className:(0,c.A)("alert alert--success",e.className),children:e.children})}function D(e){return(0,s.jsx)("svg",{viewBox:"0 0 14 16",...e,children:(0,s.jsx)("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})})}const L={icon:(0,s.jsx)(D,{}),title:(0,s.jsx)(r.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)",children:"info"})};function b(e){return(0,s.jsx)(x,{...L,...e,className:(0,c.A)("alert alert--info",e.className),children:e.children})}function y(e){return(0,s.jsx)("svg",{viewBox:"0 0 16 16",...e,children:(0,s.jsx)("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})})}const A={icon:(0,s.jsx)(y,{}),title:(0,s.jsx)(r.A,{id:"theme.admonition.warning",description:"The default label used for the Warning admonition (:::warning)",children:"warning"})};function R(e){return(0,s.jsx)("svg",{viewBox:"0 0 12 16",...e,children:(0,s.jsx)("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})})}const T={icon:(0,s.jsx)(R,{}),title:(0,s.jsx)(r.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)",children:"danger"})};const N={icon:(0,s.jsx)(y,{}),title:(0,s.jsx)(r.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)",children:"caution"})};const C={...{note:j,tip:U,info:b,warning:function(e){return(0,s.jsx)(x,{...A,...e,className:(0,c.A)("alert alert--warning",e.className),children:e.children})},danger:function(e){return(0,s.jsx)(x,{...T,...e,className:(0,c.A)("alert alert--danger",e.className),children:e.children})}},...{secondary:e=>(0,s.jsx)(j,{title:"secondary",...e}),important:e=>(0,s.jsx)(b,{title:"important",...e}),success:e=>(0,s.jsx)(U,{title:"success",...e}),caution:function(e){return(0,s.jsx)(x,{...N,...e,className:(0,c.A)("alert alert--warning",e.className),children:e.children})}}};function S(e){const t=i(e),n=(o=t.type,C[o]||(console.warn(`No admonition component found for admonition type "${o}". Using Info as fallback.`),C.info));var o;return(0,s.jsx)(n,{...t})}}}]);