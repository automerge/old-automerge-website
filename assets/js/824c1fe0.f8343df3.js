"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1140],{4331:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var o=t(758);const i={},s=o.createContext(i);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(s.Provider,{value:n},e.children)}},6423:(e,n,t)=>{t.d(n,{A:()=>i});t(758);var o=t(6070);function i(e){let{children:n}=e;return(0,o.jsxs)("div",{className:"exercise",children:[(0,o.jsx)("div",{className:"exercise-header",children:(0,o.jsx)("h3",{children:"Exercise"})}),(0,o.jsx)("div",{className:"exercise-content",children:n})]})}},8628:(e,n,t)=>{t.d(n,{A:()=>i});t(758);var o=t(6070);function i(e){let{children:n}=e;return(0,o.jsxs)("div",{className:"solution",children:[(0,o.jsx)("div",{className:"solution-header",children:(0,o.jsx)("h4",{children:"Solution"})}),(0,o.jsx)("div",{className:"solution-content",children:n})]})}},9312:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"tutorial/react","title":"React Integration","description":"Repos in React: RepoContext","source":"@site/docs/tutorial/05-react.mdx","sourceDirName":"tutorial","slug":"/tutorial/react","permalink":"/docs/tutorial/react","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/tutorial/05-react.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"React Integration"},"sidebar":"tutorialSidebar","previous":{"title":"Load documents by URL","permalink":"/docs/tutorial/load_by_url"},"next":{"title":"Network Sync","permalink":"/docs/tutorial/network-sync"}}');var i=t(6070),s=t(4331),c=(t(9821),t(6423));t(8628);const a={title:"React Integration"},d=void 0,r={},l=[{value:"Repos in React: <code>RepoContext</code>",id:"repos-in-react-repocontext",level:3},{value:"Add a <code>RepoContext</code> to the React app",id:"add-a-repocontext-to-the-react-app",level:4},{value:"Working with Documents in React",id:"working-with-documents-in-react",level:2},{value:"Pass an <code>AutomergeUrl</code> to the <code>App</code>",id:"pass-an-automergeurl-to-the-app",level:4},{value:"Reading a document",id:"reading-a-document",level:3},{value:"Checking it works",id:"checking-it-works",level:4},{value:"Editing a document",id:"editing-a-document",level:3},{value:"Creating a new Item",id:"creating-a-new-item",level:4},{value:"Updating the <code>done</code> state",id:"updating-the-done-state",level:3},{value:"Updating text",id:"updating-text",level:3},{value:"Checking your work",id:"checking-your-work",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h3,{id:"repos-in-react-repocontext",children:["Repos in React: ",(0,i.jsx)(n.code,{children:"RepoContext"})]}),"\n",(0,i.jsxs)(n.p,{children:["We've set up a ",(0,i.jsx)(n.code,{children:"Repo"})," which stores its data locally and syncs documents between tabs, and we have a mechanism for sharing documents via URL. Now we need to actually integrate this with our task list, which is a React application."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsxs)(n.a,{href:"https://github.com/automerge/automerge-repo/tree/main/packages/automerge-repo-react-hooks",children:[(0,i.jsx)(n.code,{children:"@automerge/react"})," package"]})," provides some React-specific conveniences for working with Automerge repositories. The first thing we have to do is setup a ",(0,i.jsx)(n.code,{children:"RepoContext"})," to make the ",(0,i.jsx)(n.code,{children:"Repo"})," available inside our React components. Then, we can use the hooks provided by ",(0,i.jsx)(n.code,{children:"@automerge/react"})," to load and modify documents from within the React app."]}),"\n",(0,i.jsxs)(c.A,{children:[(0,i.jsxs)(n.h4,{id:"add-a-repocontext-to-the-react-app",children:["Add a ",(0,i.jsx)(n.code,{children:"RepoContext"})," to the React app"]}),(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"RepoContext"})," makes your repo and its documents available throughout your React application, via ",(0,i.jsx)(n.code,{children:"useRepo"})," and ",(0,i.jsx)(n.code,{children:"useDocument"})," hooks which can be called in any client component."]}),(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.code,{children:"main.tsx"}),", import ",(0,i.jsx)(n.code,{children:"RepoContext"})," and modify the ",(0,i.jsx)(n.code,{children:"React.render()"})," call to wrap the ",(0,i.jsx)(n.code,{children:"App"})," component with a ",(0,i.jsx)(n.code,{children:"RepoContext.Provider"}),", passing in your fresh new ",(0,i.jsx)(n.code,{children:"repo"})," to the context's ",(0,i.jsx)(n.code,{children:"value"})," prop."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'// ...\n\nimport { initTaskList, TaskList } from "./components/TaskList.tsx";\nimport {\n  Repo,\n  BroadcastChannelNetworkAdapter,\n  IndexedDBStorageAdapter,\n  // highlight-next-line\n  RepoContext,\n  isValidAutomergeUrl,\n  DocHandle,\n} from "@automerge/react";\n\n// ...\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    <Suspense fallback={<div>Loading a document...</div>}>\n      // highlight-next-line\n      <RepoContext.Provider value={repo}>\n        <App taskList={initTaskList()} />\n      // highlight-next-line\n      </RepoContext.Provider>\n    </Suspense>\n  </React.StrictMode>,\n);\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"working-with-documents-in-react",children:"Working with Documents in React"}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have a ",(0,i.jsx)(n.code,{children:"RepoContext"})," set up we can use the ",(0,i.jsx)(n.code,{children:"useDocument"})," hook to load the URL which we have extracted from the page's hash. This will give us access to the document we want to work with."]}),"\n",(0,i.jsxs)(n.p,{children:["Similar to React's ",(0,i.jsx)(n.code,{children:"useState"}),", ",(0,i.jsx)(n.code,{children:"useDocument"})," returns a two-item array with a reactive ",(0,i.jsx)(n.code,{children:"doc"})," value representing the document's current contents and a ",(0,i.jsx)(n.code,{children:"changeDoc"})," function which can be used to update that value."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"doc"})," object will look and feel just like a Plain Old Javascript Object, because it is one. Just like with ",(0,i.jsx)(n.code,{children:"useState"}),", changes directly to the value won't behave the way you expect. Use the ",(0,i.jsx)(n.code,{children:"changeDoc"})," callback to update the document, recording your changes, and both saving and replicating them."]}),"\n",(0,i.jsx)(n.p,{children:"There are two steps to updating the app to use this new functionality:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Modify the ",(0,i.jsx)(n.code,{children:"App"})," and ",(0,i.jsx)(n.code,{children:"TaskList"})," components to accept an ",(0,i.jsx)(n.code,{children:"AutomergeUrl"})," instead of a ",(0,i.jsx)(n.code,{children:"TaskList"})]}),"\n",(0,i.jsxs)(n.li,{children:["Modify the ",(0,i.jsx)(n.code,{children:"App"})," component to use ",(0,i.jsx)(n.code,{children:"useDocument"})," to load and modify the document"]}),"\n"]}),"\n",(0,i.jsxs)(c.A,{children:[(0,i.jsxs)(n.h4,{id:"pass-an-automergeurl-to-the-app",children:["Pass an ",(0,i.jsx)(n.code,{children:"AutomergeUrl"})," to the ",(0,i.jsx)(n.code,{children:"App"})]}),(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"App"})," and ",(0,i.jsx)(n.code,{children:"TaskList"})," components currently expect a ",(0,i.jsx)(n.code,{children:"TaskList"})," object to be passed to them, but now we are moving to using Automerge we want to pass an ",(0,i.jsx)(n.code,{children:"AutomergeUrl"})," and have the ",(0,i.jsx)(n.code,{children:"TaskList"})," component load the document using ",(0,i.jsx)(n.code,{children:"useDocument"}),". The first step then is to modify these components to accept an ",(0,i.jsx)(n.code,{children:"AutomergeUrl"})," instead of a ",(0,i.jsx)(n.code,{children:"TaskList"})," and modify ",(0,i.jsx)(n.code,{children:"main.tsx"})," to pass the URL to ",(0,i.jsx)(n.code,{children:"App"}),"."]}),(0,i.jsxs)(n.p,{children:["First modify the ",(0,i.jsx)(n.code,{children:"TaskList"})," component:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/components/TaskList.tsx"',children:'// ..\n// higlight-next-line\nimport { type AutomergeUrl } from "@automerge/react";\n\n// ..\n\nexport const TaskList: React.FC<{\n  // highlight-next-line\n  docUrl: AutomergeUrl;\n}> = ({ docUrl }) => {\n  // ..\n};\n'})}),(0,i.jsxs)(n.p,{children:["Next the ",(0,i.jsx)(n.code,{children:"App"})," component:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/App.tsx"',children:'//..\n// highlight-next-line\nimport { type AutomergeUrl } from "@automerge/react";\n\n// highlight-next-line\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  return (\n    <>\n      // ..\n\n      <main>\n        <div className="task-list">\n          // highlight-next-line\n          <TaskList docUrl={docUrl} />\n        </div>\n      </main>\n\n      // ..\n    </>\n  );\n}\n// ..\n'})}),(0,i.jsxs)(n.p,{children:["Finally, update ",(0,i.jsx)(n.code,{children:"main.tsx"})," to pass the ",(0,i.jsx)(n.code,{children:"docUrl"})," to the ",(0,i.jsx)(n.code,{children:"App"})," component:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'// ...\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    <Suspense fallback={<div>Loading a document...</div>}>\n      <RepoContext.Provider value={repo}>\n        // highlight-next-line\n        <App docUrl={window.handle.url} />\n      </RepoContext.Provider>\n    </Suspense>\n  </React.StrictMode>,\n);\n'})}),(0,i.jsxs)(n.p,{children:["At this point, the ",(0,i.jsx)(n.code,{children:"App"})," component is set up to accept an ",(0,i.jsx)(n.code,{children:"AutomergeUrl"}),", and the ",(0,i.jsx)(n.code,{children:"TaskList"})," component is ready to load the document using that URL. However, we still need to implement the logic to read and modify the document."]})]}),"\n",(0,i.jsxs)(c.A,{children:[(0,i.jsx)(n.h3,{id:"reading-a-document",children:"Reading a document"}),(0,i.jsxs)(n.p,{children:["Let's look at reading the contents of a document. Until the document loads, it's undefined. After that, it will become a POJO. First, let's update the ",(0,i.jsx)(n.code,{children:"TaskList"})," component to use the ",(0,i.jsx)(n.code,{children:"useDocument"})," hook to load the task list state."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/TaskList.tsx"',children:'// ..\n\n// highlight-next-line\nimport { AutomergeUrl, useDocument } from "@automerge/react";\n\n// ..\n\nexport const TaskList: React.FC<{\n  docUrl: AutomergeUrl;\n}> = ({ docUrl }) => {\n  // highlight-start\n  const [doc, changeDoc] = useDocument<TaskList>(docUrl, {\n    // This hooks the `useDocument` into reacts suspense infrastructure so the whole component\n    // only renderes once the document is loaded\n    suspense: true,\n  });\n\n  return (\n    <>\n      <button type="button">\n        <b>+</b> New task\n      </button>\n\n      <div id="task-list">\n        {doc &&\n          doc.tasks?.map(({ title, done }, index) => (\n            <div className="task" key={index}>\n              <input type="checkbox" checked={done} />\n\n              <input\n                type="text"\n                placeholder="What needs doing?"\n                value={title || ""}\n                style={done ? { textDecoration: "line-through" } : {}}\n              />\n            </div>\n          ))}\n      </div>\n    </>\n  );\n  // highlight-end\n};\n'})}),(0,i.jsx)(n.h4,{id:"checking-it-works",children:"Checking it works"}),(0,i.jsxs)(n.p,{children:["At this point we haven't hooked up any way of modifying the document. But we can check that the state of the document is reflected in the UI using ",(0,i.jsx)(n.code,{children:"window.handle"}),"."]}),(0,i.jsx)(n.p,{children:"First, create a new list item. Open the console and type:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'window.handle.change(d => d.tasks.push({title: "Milk", done: false}))\n'})}),(0,i.jsx)(n.p,{children:'You should see a new task titled "Milk" appear in the UI.'}),(0,i.jsx)(n.p,{children:"Now let's mark it as done. Open the console again and type:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"window.handle.change(d => d.tasks[d.tasks.length - 1].done = true)\n"})}),(0,i.jsx)(n.p,{children:"You should see the checkbox for the final task in the list become ticked in the UI."})]}),"\n",(0,i.jsx)(n.h3,{id:"editing-a-document",children:"Editing a document"}),"\n",(0,i.jsxs)(n.p,{children:["The Automerge equivalent of ",(0,i.jsx)(n.code,{children:"setState(state => state + 1)"})," is ",(0,i.jsx)(n.code,{children:"changeDoc(doc => doc.state += 1)"}),". ",(0,i.jsx)(n.code,{children:"changeDoc"})," is the only way to update a document and will record any mutations you make in your callback to the ",(0,i.jsx)(n.code,{children:"doc"})," object."]}),"\n",(0,i.jsx)(n.p,{children:"There's one important difference between your usual JS style and working with an Automerge document: you will generally want to avoid immutable style."}),"\n",(0,i.jsx)(n.p,{children:"It's idiomatic in JS to use syntax like spread operators to update a document, but if you do this, you'll make merging with other users ineffective. That's because Automerge doesn't second-guess your intention: if you replace the whole array, we'll trust that's what you meant to do! Instead, you'll want to only update the data you actually want to change."}),"\n",(0,i.jsx)(n.p,{children:"We've got three places we edit the document: creating a new item, toggling completion, and editing the item's text."}),"\n",(0,i.jsx)(n.h4,{id:"creating-a-new-item",children:"Creating a new Item"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/TaskList.tsx"',children:'// ...\n\nexport const TaskList: React.FC<{\n  docUrl: AutomergeUrl;\n}> = ({ docUrl }) => {\n  const [doc, changeDoc] = useDocument<TaskList>(docUrl, {\n    // This hooks the `useDocument` into reacts suspense infrastructure so the whole component\n    // only renderes once the document is loaded\n    suspense: true,\n  });\n\n  return (\n    <>\n      <button\n        type="button"\n        onClick={() => {\n          // highlight-start\n          changeDoc((d) =>\n            d.tasks.unshift({\n              title: "",\n              done: false,\n            }),\n          );\n          // highlight-end\n        }}\n      >\n        <b>+</b> New task\n      </button>\n\n      <div id="task-list">\n        {doc &&\n          doc.tasks?.map(({ title, done }, index) => (\n            <div className="task" key={index}>\n              <input type="checkbox" checked={done} />\n\n              <input\n                type="text"\n                placeholder="What needs doing?"\n                value={title || ""}\n                style={done ? { textDecoration: "line-through" } : {}}\n              />\n            </div>\n          ))}\n      </div>\n    </>\n  );\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, we replace the React ",(0,i.jsx)(n.code,{children:"setState"})," style array spread syntax with an \"unshift\" call. Remember, Automerge does what you ask, so if you replace the complete array, your changes won't merge well with other users'."]}),"\n",(0,i.jsxs)(n.h3,{id:"updating-the-done-state",children:["Updating the ",(0,i.jsx)(n.code,{children:"done"})," state"]}),"\n",(0,i.jsxs)(n.p,{children:["Updating the task's state is similar, but we use the index of the item to make sure we target the right item. If we weren't iterating over the array already, we could use ",(0,i.jsx)(n.code,{children:".find()"})," to determine the index of the item we need."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/TaskList.tsx"',children:'// ..\n\nexport const TaskList: React.FC<{\n  docUrl: AutomergeUrl;\n}> = ({ docUrl }) => {\n  const [doc, changeDoc] = useDocument<TaskList>(docUrl, {\n    // This hooks the `useDocument` into reacts suspense infrastructure so the whole component\n    // only renderes once the document is loaded\n    suspense: true,\n  });\n\n  return (\n    <>\n      <button\n        type="button"\n        onClick={() => {\n          changeDoc((d) =>\n            d.tasks.unshift({\n              title: "",\n              done: false,\n            }),\n          );\n        }}\n      >\n        <b>+</b> New task\n      </button>\n\n      <div id="task-list">\n        {doc &&\n          doc.tasks?.map(({ title, done }, index) => (\n            <div className="task" key={index}>\n              <input\n                type="checkbox"\n                checked={done}\n                // highlight-start\n                onChange={() =>\n                  changeDoc((d) => {\n                    d.tasks[index].done = !d.tasks[index].done;\n                  })\n                }\n                //highlight-end\n              />\n\n              <input\n                type="text"\n                placeholder="What needs doing?"\n                value={title || ""}\n                style={done ? { textDecoration: "line-through" } : {}}\n              />\n            </div>\n          ))}\n      </div>\n    </>\n  );\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"updating-text",children:"Updating text"}),"\n",(0,i.jsx)(n.p,{children:"Finally, we're going to handle text a little differently in this example. Following the same principle we discuss above, if you reassign a text field in an Automerge document, we will replace the whole string. This might be what you want in some cases, but often, you'll want to support collaborative editing. This can be particularly important on large documents."}),"\n",(0,i.jsxs)(n.p,{children:["There are two approaches you can use here. The simplest approach is to use the utility function ",(0,i.jsx)(n.code,{children:"updateText"}),". It compares the before-and-after values of a string and applies a minimum edit script to combine the two. Typically for a more advanced integration with a text editor, you would use the ",(0,i.jsx)(n.code,{children:"Automerge.splice()"})," function as part of an event handler, or -- ideally -- you'd just use an existing text-editor plugin like ",(0,i.jsx)(n.code,{children:"@automerge/codemirror"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["First, we'll add ",(0,i.jsx)(n.code,{children:"updateText"})," to our imports from the library."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { updateText } from "@automerge/react";\n'})}),"\n",(0,i.jsx)(n.p,{children:"Next, we replace the text updating function with one that uses it instead of just replacing the value completely."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/TaskList.tsx"',children:'// ...\n\nexport const TaskList: React.FC<{\n  docUrl: AutomergeUrl;\n}> = ({ docUrl }) => {\n  const [doc, changeDoc] = useDocument<TaskList>(docUrl, {\n    // This hooks the `useDocument` into reacts suspense infrastructure so the whole component\n    // only renderes once the document is loaded\n    suspense: true,\n  });\n\n  return (\n    <>\n      <button\n        type="button"\n        onClick={() => {\n          changeDoc((d) =>\n            d.tasks.unshift({\n              title: "",\n              done: false,\n            }),\n          );\n        }}\n      >\n        <b>+</b> New task\n      </button>\n\n      <div id="task-list">\n        {doc &&\n          doc.tasks?.map(({ title, done }, index) => (\n            <div className="task" key={index}>\n              <input\n                type="checkbox"\n                checked={done}\n                onChange={() =>\n                  changeDoc((d) => {\n                    d.tasks[index].done = !d.tasks[index].done;\n                  })\n                }\n              />\n\n              <input\n                type="text"\n                placeholder="What needs doing?"\n                value={title || ""}\n                // highlight-start\n                onChange={(e) =>\n                  changeDoc((d) => {\n                    updateText(d, ["tasks", index, "title"], e.target.value);\n                  })\n                }\n                // highlight-end\n                style={done ? { textDecoration: "line-through" } : {}}\n              />\n            </div>\n          ))}\n      </div>\n    </>\n  );\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"checking-your-work",children:"Checking your work"}),"\n",(0,i.jsx)(n.p,{children:"We've finished wiring up the UI, we've got link sharing via the URL hash and storage and synchronisation between tabs. If you open the application in one tab, then copy the URL and open it in another you should be able to create new tasks, toggle their done state, and update the description and see the changes synchronise between tabs."}),"\n",(0,i.jsx)(n.p,{children:"Next, to sync over the network."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},9821:(e,n,t)=>{t.d(n,{A:()=>M});var o=t(758),i=t(6070);function s(e){const{mdxAdmonitionTitle:n,rest:t}=function(e){const n=o.Children.toArray(e),t=n.find((e=>o.isValidElement(e)&&"mdxAdmonitionTitle"===e.type)),s=n.filter((e=>e!==t)),c=t?.props.children;return{mdxAdmonitionTitle:c,rest:s.length>0?(0,i.jsx)(i.Fragment,{children:s}):null}}(e.children),s=e.title??n;return{...e,...s&&{title:s},children:t}}var c=t(3526),a=t(1311),d=t(7967);const r="admonition_BudP",l="admonitionHeading_3rRN",h="admonitionIcon_GUtA",u="admonitionContent_Y5R8";function p(e){let{type:n,className:t,children:o}=e;return(0,i.jsx)("div",{className:(0,c.A)(d.G.common.admonition,d.G.common.admonitionType(n),r,t),children:o})}function m(e){let{icon:n,title:t}=e;return(0,i.jsxs)("div",{className:l,children:[(0,i.jsx)("span",{className:h,children:n}),t]})}function x(e){let{children:n}=e;return n?(0,i.jsx)("div",{className:u,children:n}):null}function g(e){const{type:n,icon:t,title:o,children:s,className:c}=e;return(0,i.jsxs)(p,{type:n,className:c,children:[o||t?(0,i.jsx)(m,{title:o,icon:t}):null,(0,i.jsx)(x,{children:s})]})}function j(e){return(0,i.jsx)("svg",{viewBox:"0 0 14 16",...e,children:(0,i.jsx)("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})})}const f={icon:(0,i.jsx)(j,{}),title:(0,i.jsx)(a.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)",children:"note"})};function w(e){return(0,i.jsx)(g,{...f,...e,className:(0,c.A)("alert alert--secondary",e.className),children:e.children})}function k(e){return(0,i.jsx)("svg",{viewBox:"0 0 12 16",...e,children:(0,i.jsx)("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})})}const v={icon:(0,i.jsx)(k,{}),title:(0,i.jsx)(a.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)",children:"tip"})};function y(e){return(0,i.jsx)(g,{...v,...e,className:(0,c.A)("alert alert--success",e.className),children:e.children})}function b(e){return(0,i.jsx)("svg",{viewBox:"0 0 14 16",...e,children:(0,i.jsx)("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})})}const R={icon:(0,i.jsx)(b,{}),title:(0,i.jsx)(a.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)",children:"info"})};function A(e){return(0,i.jsx)(g,{...R,...e,className:(0,c.A)("alert alert--info",e.className),children:e.children})}function T(e){return(0,i.jsx)("svg",{viewBox:"0 0 16 16",...e,children:(0,i.jsx)("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})})}const N={icon:(0,i.jsx)(T,{}),title:(0,i.jsx)(a.A,{id:"theme.admonition.warning",description:"The default label used for the Warning admonition (:::warning)",children:"warning"})};function U(e){return(0,i.jsx)("svg",{viewBox:"0 0 12 16",...e,children:(0,i.jsx)("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})})}const C={icon:(0,i.jsx)(U,{}),title:(0,i.jsx)(a.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)",children:"danger"})};const L={icon:(0,i.jsx)(T,{}),title:(0,i.jsx)(a.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)",children:"caution"})};const D={...{note:w,tip:y,info:A,warning:function(e){return(0,i.jsx)(g,{...N,...e,className:(0,c.A)("alert alert--warning",e.className),children:e.children})},danger:function(e){return(0,i.jsx)(g,{...C,...e,className:(0,c.A)("alert alert--danger",e.className),children:e.children})}},...{secondary:e=>(0,i.jsx)(w,{title:"secondary",...e}),important:e=>(0,i.jsx)(A,{title:"important",...e}),success:e=>(0,i.jsx)(y,{title:"success",...e}),caution:function(e){return(0,i.jsx)(g,{...L,...e,className:(0,c.A)("alert alert--warning",e.className),children:e.children})}}};function M(e){const n=s(e),t=(o=n.type,D[o]||(console.warn(`No admonition component found for admonition type "${o}". Using Info as fallback.`),D.info));var o;return(0,i.jsx)(t,{...n})}}}]);