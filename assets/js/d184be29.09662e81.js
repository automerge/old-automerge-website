"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6],{4331:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>a});var o=t(758);const n={},i=o.createContext(n);function s(e){const r=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(i.Provider,{value:r},e.children)}},9441:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"cookbook/rich-text-prosemirror-react","title":"Prosemirror + React + Automerge","description":"Automerge supports rich text editing on top of ProseMirror. This guide will show you how to set up a simple collaborative rich text editor in React using Automerge and ProseMirror.","source":"@site/docs/cookbook/rich-text-prosemirror-react.md","sourceDirName":"cookbook","slug":"/cookbook/rich-text-prosemirror-react","permalink":"/docs/cookbook/rich-text-prosemirror-react","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/cookbook/rich-text-prosemirror-react.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Modeling Data","permalink":"/docs/cookbook/modeling-data"},"next":{"title":"Prosemirror + VanillaJS + Automerge","permalink":"/docs/cookbook/rich-text-prosemirror-vanilla"}}');var n=t(6070),i=t(4331);const s={sidebar_position:2},a="Prosemirror + React + Automerge",c={},l=[];function d(e){const r={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"prosemirror--react--automerge",children:"Prosemirror + React + Automerge"})}),"\n",(0,n.jsxs)(r.p,{children:["Automerge supports rich text editing on top of ",(0,n.jsx)(r.a,{href:"https://prosemirror.net/",children:"ProseMirror"}),". This guide will show you how to set up a simple collaborative rich text editor in React using Automerge and ProseMirror."]}),"\n",(0,n.jsxs)(r.p,{children:["All the code here can be found at ",(0,n.jsx)(r.a,{href:"https://github.com/automerge/automerge-prosemirror/tree/main/examples/react",children:"https://github.com/automerge/automerge-prosemirror/tree/main/examples/react"})]}),"\n",(0,n.jsxs)(r.p,{children:["First, create a an example vite app using the ",(0,n.jsx)(r.code,{children:"@automerge/vite-app"})," template. This will give you a basic React app with the Automerge dependencies already installed."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"yarn create @automerge/vite-app\n"})}),"\n",(0,n.jsx)(r.p,{children:"Then install our prosemirror dependencies"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"yarn add @automerge/prosemirror prosemirror-example-setup prosemirror-model prosemirror-state prosemirror-view\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Now, the app created by ",(0,n.jsx)(r.code,{children:"@automerge/vite-app"})," creates a document which contains a ",(0,n.jsx)(r.code,{children:"Counter"}),", but we want a ",(0,n.jsx)(r.code,{children:"string"})," which will contain the text. Modify ",(0,n.jsx)(r.code,{children:"main.tsx"})," so that the handle initialization logic looks like this:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-jsx",metastring:'title="src/main.tsx"',children:'...\nlet handle\nif (isValidAutomergeUrl(rootDocUrl)) {\n  handle = repo.find(rootDocUrl)\n} else {\n  handle = repo.create({text: ""})\n}\n...\n'})}),"\n",(0,n.jsx)(r.p,{children:"First, let's create a basic skeleton component which just loads the document handle. The prosemirror bindings require that the document handle be loaded before we begin, so we'll add a bit of boilerplate to achieve this:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-jsx",metastring:'title="src/App.tsx"',children:'import { AutomergeUrl } from "@automerge/automerge-repo"\nimport { useHandle } from "@automerge/automerge-repo-react-hooks"\nimport { useEffect, useState } from "react"\n\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  const handle = useHandle<{text: string}>(docUrl)\n  const [loaded, setLoaded] = useState(handle && handle.docSync() != null)\n  useEffect(() => {\n    if (handle != null) {\n      handle.whenReady().then(() => {\n        if (handle.docSync() != null) {\n          setLoaded(true)\n        }\n      })\n    }\n  }, [handle])\n\n  return <div id="editor"></div>\n}\n\nexport default App\n'})}),"\n",(0,n.jsxs)(r.p,{children:["Now, we're going to create a ProseMirror editor. Prosemirror manages its own UI and state, it just needs to be attached to the DOM somehow. To achieve this we'll use the ",(0,n.jsx)(r.code,{children:"useRef"})," hook to get hold of a reference to a dom element inside a React component which we can pass to prosemirror."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-jsx",metastring:'title="src/App.tsx"',children:'import { AutomergeUrl } from "@automerge/automerge-repo"\nimport { useHandle } from "@automerge/automerge-repo-react-hooks"\n// highlight-start\nimport { useEffect, useRef, useState } from "react"\nimport {EditorState} from "prosemirror-state"\nimport {EditorView} from "prosemirror-view"\nimport {exampleSetup} from "prosemirror-example-setup"\nimport { init } from "@automerge/prosemirror"\nimport "prosemirror-example-setup/style/style.css"\nimport "prosemirror-menu/style/menu.css"\nimport "prosemirror-view/style/prosemirror.css"\nimport "./App.css"\n// highlight-end\n\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  const editorRoot = useRef<HTMLDivElement>(null)\n  const handle = useHandle<{text: string}>(docUrl)\n  const [loaded, setLoaded] = useState(handle && handle.docSync() != null)\n  useEffect(() => {\n    if (handle != null) {\n      handle.whenReady().then(() => {\n        if (handle.docSync() != null) {\n          setLoaded(true)\n        }\n      })\n    }\n  }, [handle])\n\n  // highlight-start\n  const [view, setView] = useState<EditorView | null>(null)\n  useEffect(() => {\n    if (editorRoot.current != null && loaded) {\n      // This is the integration with automerge   \n      const { pmDoc: doc, schema, plugin } = init(handle!, ["text"])\n      const plugins = exampleSetup({schema})\n      plugins.push(plugin)\n      const view = new EditorView(editorRoot.current, {\n        state: EditorState.create({\n          schema,\n          plugins,\n          doc,\n        }),\n      })\n      setView(view)\n    }\n    return () => {\n      if (view) {\n        view.destroy()\n        setView(null)\n      }\n    }\n  }, [editorRoot, loaded])\n  // highlight-end\n\n  return <div id="editor" ref={editorRoot}></div>\n}\n\nexport default App\n'})}),"\n",(0,n.jsxs)(r.p,{children:["At this point if you run the application you'll find that there's a working prosemirror editor but it looks rubbish. Add the following to ",(0,n.jsx)(r.code,{children:"src/App.css"})," and things will look a lot better:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-css",metastring:'title="src/App.css"',children:"#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  display:flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100vh;\n}\n\n/* center the editor inside the #root */\n#editor {\n  margin: 0 auto;\n  width: 100%;\n  max-width: 800px;\n  flex: 1;\n  background-color: #f8f9fa;\n  color: #333;\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Alright, now we're ready to collaborate, you can load up the app in a different tab, or a different browser (the URL will contain a document URL after the ",(0,n.jsx)(r.code,{children:"#"}),"), and you can see changes being merged from one side to the other."]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);