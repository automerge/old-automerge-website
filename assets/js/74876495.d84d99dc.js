"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6505],{2693:(e,t,n)=>{n.r(t),n.d(t,{Exercise:()=>g,Figure:()=>j,Solution:()=>x,assets:()=>m,contentTitle:()=>p,default:()=>f,frontMatter:()=>u,metadata:()=>o,toc:()=>w});const o=JSON.parse('{"id":"quickstart","title":"A Builder\'s Tour of Automerge","description":"Automerge is a suite of tools for building local-first web applications with real-time synchronization that works on and offline.","source":"@site/docs/quickstart.mdx","sourceDirName":".","slug":"/quickstart","permalink":"/docs/quickstart","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/quickstart.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"A Builder\'s Tour of Automerge"},"sidebar":"tutorialSidebar","previous":{"title":"Welcome to Automerge","permalink":"/docs/hello"},"next":{"title":"Concepts","permalink":"/docs/concepts"}}');var r=n(4848),a=n(8453),i=n(2362),s=n(5537),c=n(9329);const d=n.p+"assets/medias/task-list-sync-8b4592fc5718f85e407172bca42a9c13.webm",l=n.p+"assets/medias/task-list-pre-automerge-9958b1abec46a458fdb55736172b5960.webm",h=(n.p,n.p+"assets/images/amg-arch-KleppmannStrangeLoop2023-747be6a944d8f4a21291d336e8666f86.webp"),u={sidebar_position:1,title:"A Builder's Tour of Automerge"},p=void 0,m={};function g({children:e}){return(0,r.jsx)(i.A,{type:"tip",title:"Exercise",children:e})}function x({children:e}){return(0,r.jsxs)("details",{children:[(0,r.jsx)("summary",{children:"Solution"}),e]})}function j({src:e,alt:t,caption:n}){const o={width:"100%",objectFit:"contain",padding:"1em",backgroundColor:"inherit"};return(0,r.jsxs)("figure",{style:{margin:"1em auto",textAlign:"center",border:"1px solid var(--ifm-color-primary)",borderRadius:20,maxWidth:720},children:[e.endsWith(".webm")?(0,r.jsx)("video",{src:e,type:"video/webm",style:o,alt:t||n,autoPlay:!0,loop:!0,muted:!0}):(0,r.jsx)("img",{src:e,type:"img/webp",style:o,alt:t||n}),(0,r.jsx)("figcaption",{style:{padding:"1em"},children:n})]})}const w=[{value:"Setup",id:"setup",level:2},{value:"Architecture of an Automerge App",id:"architecture-of-an-automerge-app",level:2},{value:"Manage docs with a <code>Repo</code>",id:"manage-docs-with-a-repo",level:2},{value:"Storage &amp; Network Adapters",id:"storage--network-adapters",level:3},{value:"Create a Repo to hold your documents",id:"create-a-repo-to-hold-your-documents",level:4},{value:"Repos in React: <code>RepoContext</code>",id:"repos-in-react-repocontext",level:3},{value:"Add a <code>RepoContext</code> to the React app",id:"add-a-repocontext-to-the-react-app",level:4},{value:"Doc Handles &amp; URLs",id:"doc-handles--urls",level:3},{value:"Quick &amp; Dirty URL-based sharing",id:"quick--dirty-url-based-sharing",level:3},{value:"Working with your new document",id:"working-with-your-new-document",level:2},{value:"Docs in React: <code>useDocument</code>",id:"docs-in-react-usedocument",level:3},{value:"Reading a document",id:"reading-a-document",level:4},{value:"Editing a document",id:"editing-a-document",level:3},{value:"Updating text",id:"updating-text",level:3},{value:"Collaboration in Automerge",id:"collaboration-in-automerge",level:2},{value:"Collaborating Locally",id:"collaborating-locally",level:3},{value:"Collaborating over the internet",id:"collaborating-over-the-internet",level:3},{value:"Connect to a sync server via a websocket",id:"connect-to-a-sync-server-via-a-websocket",level:4},{value:"Network Not Required",id:"network-not-required",level:3},{value:"Next Steps",id:"next-steps",level:2}];function y(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Automerge is a suite of tools for building ",(0,r.jsx)(t.a,{href:"https://www.inkandswitch.com/local-first",children:"local-first"})," web applications with real-time synchronization that works on and offline."]}),"\n",(0,r.jsxs)(t.p,{children:["In this tutorial, you'll build a local-first multiplayer app with TypeScript, React, ",(0,r.jsx)(t.a,{href:"https://vite.dev",children:"Vite"}),", and Automerge. You'll discover how to:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Represent data as Automerge ",(0,r.jsx)(t.a,{href:"/docs/concepts/#documents",children:"Documents"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/docs/documents/conflicts/",children:"Change"})," documents' data and ",(0,r.jsx)(t.a,{href:"/docs/under-the-hood/merge_rules/",children:"merge"})," changes from different peers"]}),"\n",(0,r.jsxs)(t.li,{children:["Store & synchronize a set of documents in an Automerge ",(0,r.jsx)(t.a,{href:"/docs/concepts/#repositories",children:"Repository"})]}),"\n",(0,r.jsxs)(t.li,{children:["Build a multiplayer realtime web app with the Automerge ",(0,r.jsx)(t.a,{href:"https://github.com/automerge/automerge-repo/tree/main/packages/automerge-repo-react-hooks",children:"React client"})]}),"\n"]}),"\n",(0,r.jsx)(j,{src:d,alt:'Screen capture of two browser windows side-by-side showing the same app titled "Automerge Task List". As the user clicks buttons, enters text or checks boxes in one window, their changes show up immediately in the other window.',caption:"The app in action. Data is stored locally, and Automerge syncs changes between users automatically."}),"\n",(0,r.jsx)(t.h2,{id:"setup",children:"Setup"}),"\n",(0,r.jsx)(i.A,{type:"info",children:(0,r.jsxs)(t.p,{children:["All the code here can be found at the ",(0,r.jsx)(t.a,{href:"https://github.com/automerge/automerge-repo-quickstart",children:"automerge-repo-quickstart"})," repo."]})}),"\n",(0,r.jsx)(t.p,{children:"To get started:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["clone the tutorial project from ",(0,r.jsx)(t.a,{href:"https://github.com/automerge/automerge-repo-quickstart",children:"automerge-repo-quickstart"})]}),"\n",(0,r.jsxs)(t.li,{children:["switch to the ",(0,r.jsx)(t.code,{children:"without-automerge"})," branch"]}),"\n",(0,r.jsxs)(t.li,{children:["in the ",(0,r.jsx)(t.code,{children:"automerge-repo-quickstart"})," directory, install the project dependencies"]}),"\n",(0,r.jsx)(t.li,{children:"start the local Vite development server"}),"\n"]}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsx)(c.A,{value:"npm",label:"npm",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"$ git clone https://github.com/automerge/automerge-repo-quickstart\n# Cloning into 'automerge-repo-quickstart'...\n$ cd automerge-repo-quickstart\n$ git checkout without-automerge\n$ npm install\n# ...installing dependencies...\n$ npm run dev\n"})})}),(0,r.jsx)(c.A,{value:"yarn",label:"yarn",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"$ git clone https://github.com/automerge/automerge-repo-quickstart\n# Cloning into 'automerge-repo-quickstart'...\n$ cd automerge-repo-quickstart\n$ git checkout without-automerge\n$ yarn\n# ...installing dependencies...\n$ yarn dev\n"})})}),(0,r.jsx)(c.A,{value:"pnpm",label:"pnpm",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"$ git clone https://github.com/automerge/automerge-repo-quickstart\n# Cloning into 'automerge-repo-quickstart'...\n$ cd automerge-repo-quickstart\n$ git checkout without-automerge\n$ pnpm install\n# ...installing dependencies...\n$ pnpm dev\n"})})})]}),"\n",(0,r.jsxs)(t.p,{children:["Visit ",(0,r.jsx)(t.a,{href:"http://localhost:5173/automerge-repo-quickstart/",children:"localhost:5173/automerge-repo-quickstart/"}),' to see the app in its "starter" state, as a basic React app not yet using Automerge: the task list can be edited, but changes are not synced between users, and all local changes are lost when the page is closed or reloaded.']}),"\n",(0,r.jsx)(j,{src:l,alt:"Screen capture of the non-syncing app",caption:"The (unimpressive) app before you give it superpowers with Automerge"}),"\n",(0,r.jsx)(t.p,{children:"Let's fix all that with Automerge!"}),"\n",(0,r.jsx)(t.p,{children:"In the exercises that follow, you'll modify the source code to:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Configure a Repository to store & sync document changes locally"}),"\n",(0,r.jsx)(t.li,{children:"Create/retrieve a task list Document by its Document URL"}),"\n",(0,r.jsx)(t.li,{children:"Use the Automerge React client to update the Doc's data on user input"}),"\n",(0,r.jsx)(t.li,{children:"Update the Repo to also sync changes over the network (when available)"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"architecture-of-an-automerge-app",children:"Architecture of an Automerge App"}),"\n",(0,r.jsxs)(t.p,{children:["Building apps with Automerge requires familiarity with two key concepts: ",(0,r.jsx)(t.strong,{children:"Documents"})," and ",(0,r.jsx)(t.strong,{children:"Repositories"}),"."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["An Automerge ",(0,r.jsx)(t.a,{href:"/docs/concepts/#documents",children:"Document"})," (Doc) models app data using a specialized data structure that supports conflict-free collaboration via git-like merges."]}),"\n",(0,r.jsxs)(t.li,{children:["An Automerge ",(0,r.jsx)(t.a,{href:"/docs/concepts/#repositories",children:"Repository"})," (Repo) determines how/where the app stores and synchronizes those documents, locally and/or over the network."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Automerge is built in Rust, but stack-agnostic and useful for building apps on any platform, with client libraries for many popular languages/frameworks."}),"\n",(0,r.jsx)("a",{href:"https://www.youtube.com/watch?v=Mr0a5KyD6BU",title:'Watch "New algorithms for collaborative text editing" by Martin Kleppmann (Strange Loop 2023) on YouTube',children:(0,r.jsx)(j,{src:h,alt:"Diagram of automerge project components, including automerge and automerge-repo",caption:'Automerge system diagram from  "New algorithms for collaborative text editing" by Martin Kleppmann (Strange Loop 2023)'})}),"\n",(0,r.jsxs)(t.p,{children:["The foundational ",(0,r.jsx)(t.code,{children:"Document"})," data structure & related algorithms are defined in the ",(0,r.jsx)(t.a,{href:"https://github.com/automerge/automerge",children:(0,r.jsx)(t.code,{children:"@automerge/automerge"})})," core library, which used under the hood by the ",(0,r.jsx)(t.a,{href:"https://github.com/automerge/automerge-repo",children:(0,r.jsx)(t.code,{children:"@automerge/automerge-repo"})})," library, which exposes the practical conveniences for managing documents via a ",(0,r.jsx)(t.code,{children:"Repo"}),"."]}),"\n",(0,r.jsxs)(t.h2,{id:"manage-docs-with-a-repo",children:["Manage docs with a ",(0,r.jsx)(t.code,{children:"Repo"})]}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.a,{href:"/docs/repositories/",children:(0,r.jsx)(t.code,{children:"Repo"})})," keeps track of all the documents you load and makes sure they're properly synchronized and stored. It provides an interface to:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"create, modify, and manage documents locally"}),"\n",(0,r.jsx)(t.li,{children:"send & receive changes to/from others, and"}),"\n",(0,r.jsx)(t.li,{children:"merge multiple changes as needed."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Each Repo needs to know:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Where its documents should be saved, specified via a ",(0,r.jsx)(t.a,{href:"/docs/repositories/storage/",children:(0,r.jsx)(t.code,{children:"StorageAdapter"})})]}),"\n",(0,r.jsxs)(t.li,{children:["How/Where to send, retrieve, and synchronize doc updates, specified via zero or more ",(0,r.jsx)(t.a,{href:"/docs/repositories/networking/",children:(0,r.jsx)(t.code,{children:"NetworkAdapter"})}),"s"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Repo"})," constructor, which comes from ",(0,r.jsx)(t.a,{href:"https://github.com/automerge/automerge-repo",children:(0,r.jsx)(t.code,{children:"@automerge/automerge-repo"})}),", lets you create & configure a Repository, specifying the ",(0,r.jsx)(t.code,{children:"StorageAdapter"})," and ",(0,r.jsx)(t.code,{children:"NetworkAdapter"}),"(s) you need."]}),"\n",(0,r.jsxs)(t.p,{children:["Adapters can be imported from their respective ",(0,r.jsx)(t.code,{children:"@automerge/automerge-repo-storage-*"})," and ",(0,r.jsx)(t.code,{children:"@automerge/automerge-repo-network-*"})," packages."]}),"\n",(0,r.jsxs)(t.p,{children:["For convenience, we're going to use the ",(0,r.jsx)(t.code,{children:"@automerge/react"})," package to simplify our imports, but all that package does is re-export the most common dependencies that a React web application might want."]}),"\n",(0,r.jsx)(i.A,{type:"info",title:"Roll your own adapter",children:(0,r.jsxs)(t.p,{children:["If none of the pre-built adapters fit your needs, you can create ",(0,r.jsx)(t.a,{href:"/docs/repositories/storage/#roll-your-own",children:"custom adapter(s)"})," as needed."]})}),"\n",(0,r.jsx)(t.h3,{id:"storage--network-adapters",children:"Storage & Network Adapters"}),"\n",(0,r.jsx)(t.p,{children:"Currently, the task list app doesn't persist or sync any changes, even locally."}),"\n",(0,r.jsx)(t.p,{children:"To prepare to add local multiplayer capabilities to the app, you'll initialize a local-first Repo to:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["save Docs client-side in the browser's ",(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",children:"IndexedDB"}),", using the ",(0,r.jsx)(t.code,{children:"IndexedDBStorageAdapter"})," from ",(0,r.jsx)(t.code,{children:"@automerge/automerge-repo-storage-indexeddb"})]}),"\n",(0,r.jsxs)(t.li,{children:["keep local users (i.e. tabs within the same browser/origin) in sync via a ",(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API",children:"BroadcastChannel"}),", using the ",(0,r.jsx)(t.code,{children:"BroadcastChannelNetworkAdapter"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(g,{children:[(0,r.jsx)(t.h4,{id:"create-a-repo-to-hold-your-documents",children:"Create a Repo to hold your documents"}),(0,r.jsxs)(t.p,{children:["Start by adding ",(0,r.jsx)(t.code,{children:"@automerge/react"})," to your project."]}),(0,r.jsxs)(s.A,{children:[(0,r.jsx)(c.A,{value:"npm",label:"npm",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"# highlight-next-line\n$ npm install @automerge/react\n# ...installing dependencies...\n"})})}),(0,r.jsx)(c.A,{value:"yarn",label:"yarn",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"# highlight-next-line\n$ yarn add @automerge/react\n# ...installing dependencies...\n"})})}),(0,r.jsx)(c.A,{value:"pnpm",label:"pnpm",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"# highlight-next-line\n$ pnpm add @automerge/react\n# ...installing dependencies...\n"})})})]}),(0,r.jsxs)(t.p,{children:["In ",(0,r.jsx)(t.code,{children:"src/main.tsx"}),", import ",(0,r.jsx)(t.code,{children:"@automerge/react"})," and create a Repo object configured with networking and storage."]}),(0,r.jsx)(t.p,{children:"We'll start by storing our data in IndexedDB so we don't lose it when we refresh the browser, and we'll use the inefficient but simple BroadcastChannel networking adapter to keep our browser tabs in sync."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'import React from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./App.tsx";\nimport "./index.css";\n\n// highlight-start\nimport {\n  Repo,\n  BroadcastChannelNetworkAdapter,\n  IndexedDBStorageAdapter,\n} from "@automerge/react";\n\nconst repo = new Repo({\n  storage: new IndexedDBStorageAdapter(),\n  network: [new BroadcastChannelNetworkAdapter()],\n});\n// highlight-end\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n'})}),(0,r.jsx)(t.p,{children:"There are lots of other storage and networking adapters for all kinds of different environments. We'll see more of them later."})]}),"\n",(0,r.jsxs)(t.h3,{id:"repos-in-react-repocontext",children:["Repos in React: ",(0,r.jsx)(t.code,{children:"RepoContext"})]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsxs)(t.a,{href:"https://github.com/automerge/automerge-repo/tree/main/packages/automerge-repo-react-hooks",children:[(0,r.jsx)(t.code,{children:"@automerge/react"})," package"]})," provides some React-specific conveniences for working with Automerge repositories."]}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"RepoContext"})," makes your repo and its documents available throughout your React application, via ",(0,r.jsx)(t.code,{children:"useRepo"})," and ",(0,r.jsx)(t.code,{children:"useDocument"})," hooks which can be called in any client component."]}),"\n",(0,r.jsxs)(g,{children:[(0,r.jsxs)(t.h4,{id:"add-a-repocontext-to-the-react-app",children:["Add a ",(0,r.jsx)(t.code,{children:"RepoContext"})," to the React app"]}),(0,r.jsxs)(t.p,{children:["In ",(0,r.jsx)(t.code,{children:"main.tsx"}),", import ",(0,r.jsx)(t.code,{children:"RepoContext"})," and modify the ",(0,r.jsx)(t.code,{children:"React.render()"})," call to wrap the ",(0,r.jsx)(t.code,{children:"App"})," component with a ",(0,r.jsx)(t.code,{children:"RepoContext.Provider"}),", passing in your fresh new ",(0,r.jsx)(t.code,{children:"repo"})," to the context's ",(0,r.jsx)(t.code,{children:"value"})," prop."]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'import React from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./App.tsx";\nimport "./index.css";\nimport {\n  Repo,\n  BroadcastChannelNetworkAdapter,\n  IndexedDBStorageAdapter,\n  // highlight-next-line\n  RepoContext,\n} from "@automerge/react";\n\nconst repo = new Repo({\n  storage: new IndexedDBStorageAdapter(),\n  network: [new BroadcastChannelNetworkAdapter()],\n});\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    {/* highlight-next-line */}\n    <RepoContext.Provider value={repo}>\n      <App />\n      {/* highlight-next-line */}\n    </RepoContext.Provider>\n  </React.StrictMode>\n);\n'})})]}),"\n",(0,r.jsx)(t.h3,{id:"doc-handles--urls",children:"Doc Handles & URLs"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"Repo"})," isn't very useful until it has some documents in it! To create a new document, pass its initial value to ",(0,r.jsx)(t.code,{children:"repo.create()"}),", which accepts a type parameter representing your data:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'const listHandle = repo.create<TaskList>({\n  tasks: [\n    {\n      title: "Learn Automerge",\n      done: false,\n    },\n  ],\n});\n'})}),"\n",(0,r.jsxs)(t.p,{children:["The object returned from ",(0,r.jsx)(t.code,{children:"repo.create()"})," is a ",(0,r.jsx)(t.a,{href:"/docs/repositories/dochandles/",children:(0,r.jsx)(t.code,{children:"DocHandle"})}),", which provides an interface for working with the document."]}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"DocHandle"}),"'s ",(0,r.jsx)(t.code,{children:".url"})," property provides the document's unique identifier:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"listHandle.url; // automerge:37Qr33Ub26dnS2txNCjEJDC37KFT\n"})}),"\n",(0,r.jsxs)(t.p,{children:["To retrieve a handle for a document that's already in your repo, you can pass its document URL to ",(0,r.jsx)(t.code,{children:"repo.find()"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"const existingDocHandle = repo.find(existingDoc.url);\n"})}),"\n",(0,r.jsx)(t.p,{children:"It's common practice to pass document URLs around as URL hashes. For example:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"http://my-automerge-app.com/automerge-repo-quickstart/#automerge:37Qr33Ub26dnS2txNCjEJDC37KFT"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"automerge-repo"})," package exports an ",(0,r.jsx)(t.code,{children:"isValidAutomergeUrl()"})," function that you can use to determine if a given hash is a valid Document URL."]}),"\n",(0,r.jsx)(t.p,{children:"In your task list app, you'll check the page's hash and:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"retrieve the existing task list document if it exists, or"}),"\n",(0,r.jsx)(t.li,{children:"create a new document if we don't have one already."}),"\n"]}),"\n",(0,r.jsxs)(g,{children:[(0,r.jsx)(t.h3,{id:"quick--dirty-url-based-sharing",children:"Quick & Dirty URL-based sharing"}),(0,r.jsx)(t.p,{children:"Now that we have automerge added to our project and a Repo available, we're going to add a simple URL-based sharing mechanism. You might recognize this approach to link sharing from other projects. Going to the page with an empty path creates a new document and puts the ID of that document into the location's hash fragment. If you open a link that includes a valid document in the hash, we open it."}),(0,r.jsx)(t.p,{children:"This is the last bit of our setup, and while this is very convenient for prototyping and testing, it isn't the right approach for a production application. We'll discuss what we'd recommend for a production application below."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'import React from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./App.tsx";\nimport "./index.css";\nimport {\n  Repo,\n  BroadcastChannelNetworkAdapter,\n  WebsocketClientNetworkAdapter,\n  IndexedDBStorageAdapter,\n  RepoContext,\n  // highlight-next-line\n  isValidAutomergeUrl,\n} from "@automerge/react";\n\n// highlight-next-line\nimport type { TaskList } from "./App.tsx";\n\nconst repo = new Repo({\n  storage: new IndexedDBStorageAdapter(),\n  network: [\n    new WebsocketClientNetworkAdapter("wss://sync.automerge.org"),\n    new BroadcastChannelNetworkAdapter(),\n  ],\n});\n\n// highlight-start\n// Check the URL for a document to load\nconst locationHash = document.location.hash.substring(1);\n\n// Depending if we have an AutomergeUrl, either find or create the document\nlet handle;\nif (isValidAutomergeUrl(locationHash)) {\n  handle = await repo.find(locationHash);\n} else {\n  handle = repo.create<TaskList>({\n    tasks: [],\n  });\n  // Set the location hash to the new document we just made.\n  document.location.hash = handle.url;\n}\n\n// highlight-end\n\nReactDOM.createRoot(document.getElementById("root")!).render(\n  <React.StrictMode>\n    <RepoContext.Provider value={repo}>\n      {/* highlight-next-line */}\n      <App docUrl={handle.url} />\n    </RepoContext.Provider>\n  </React.StrictMode>\n);\n'})})]}),"\n",(0,r.jsx)(t.h2,{id:"working-with-your-new-document",children:"Working with your new document"}),"\n",(0,r.jsx)(t.p,{children:'We recommend you keep Automerge documents small and granular: you can load just what you need and share with other users. As a general principle, our motto is "if the data should always travel together, put it in the same document". Remember that each document has its own history, and you can\'t only share part of a document.'}),"\n",(0,r.jsx)(t.p,{children:"The simplest and idomatic way of linking docs together is to use their AutomergeUrl; we'll look at an example of that later."}),"\n",(0,r.jsxs)(t.h3,{id:"docs-in-react-usedocument",children:["Docs in React: ",(0,r.jsx)(t.code,{children:"useDocument"})]}),"\n",(0,r.jsxs)(t.p,{children:["Once you have the URL of the document you want to work with, you can access & modify it from your components with the ",(0,r.jsx)(t.code,{children:"useDocument"})," hook."]}),"\n",(0,r.jsxs)(t.p,{children:["Similar to React's ",(0,r.jsx)(t.code,{children:"useState"}),", ",(0,r.jsx)(t.code,{children:"useDocument"})," returns a two-item array with a reactive ",(0,r.jsx)(t.code,{children:"doc"})," value representing the document's current contents and a ",(0,r.jsx)(t.code,{children:"changeDoc"})," function which can be used to update that value."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"doc"})," object will look and feel just like a Plain Old Javascript Object, because it is one. Just like with ",(0,r.jsx)(t.code,{children:"useState"}),", changes directly to the value won't behave the way you expect. Use the ",(0,r.jsx)(t.code,{children:"changeDoc"})," callback to update the document, recording your changes, and both saving and replicating them."]}),"\n",(0,r.jsxs)(t.p,{children:["Now let's work with the document we created in the App component. We're going to use the ",(0,r.jsx)(t.code,{children:"useDocument"})," hook which has a similar interface to React's built-in ",(0,r.jsx)(t.code,{children:"useState"}),". When you build an application with Automerge, you don't have to worry about where updates come from. No matter whether they're local or remote, your application will update the same way as they arrive."]}),"\n",(0,r.jsxs)(g,{children:[(0,r.jsx)(t.h4,{id:"reading-a-document",children:"Reading a document"}),(0,r.jsx)(t.p,{children:"Let's look at reading the contents of a document. Until the document loads, it's undefined. After that, it will become a POJO."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/App.tsx"',children:'// ...\nimport { useState } from "react";\n// highlight-next-line\nimport { useDocument, type AutomergeUrl } from "@automerge/react";\n\n// ...\n\n// highlight-start\nfunction App({ docUrl }: { docUrl: AutomergeUrl }) {\n  const [doc, changeDoc] = useDocument<TaskList>(docUrl);\n\n  // Until the document loads, useDocument returns undefined.\n  if (!doc) return <div>Loading...</div>;\n\n  // Now we can get the tasks out of the document and render them below.\n  const { tasks } = doc;\n  // highlight-end\n\n  // ...\n}\n\nexport default App;\n'})})]}),"\n",(0,r.jsx)(t.h3,{id:"editing-a-document",children:"Editing a document"}),"\n",(0,r.jsxs)(t.p,{children:["The Automerge equivalent of ",(0,r.jsx)(t.code,{children:"setState(state => state + 1)"})," is ",(0,r.jsx)(t.code,{children:"changeDoc(doc => doc.state += 1)"}),". ",(0,r.jsx)(t.code,{children:"changeDoc"})," is the only way to update a document and will record any mutations you make in your callback to the ",(0,r.jsx)(t.code,{children:"doc"})," object."]}),"\n",(0,r.jsx)(t.p,{children:"There's one important difference between your usual JS style and working with an Automerge document: you will generally want to avoid immutable style."}),"\n",(0,r.jsx)(t.p,{children:"It's idiomatic in JS to use syntax like spread operators to update a document, but if you do this, you'll make merging with other users ineffective. That's because Automerge doens't second-guess your intention: if you replace the whole array, we'll trust that's what you meant to do! Instead, you'll want to only update the data you actually want to change."}),"\n",(0,r.jsx)(t.p,{children:"We've got three places we edit the document: creating a new item, toggling completion, and editing the item's text."}),"\n",(0,r.jsxs)(t.p,{children:["Here, we replace the React ",(0,r.jsx)(t.code,{children:"setState"})," style array spread syntax with an \"unshift\" call. Remember, Automerge does what you ask, so if you replace the complete array, your changes won't merge well with other users'."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'  <button\n    type="button"\n    onClick={() => {\n      changeDoc((d) =>\n        d.tasks.unshift({\n          title: "",\n          done: false,\n        })\n      );\n    }}\n  >\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Updating the task's state is similar, but we use the index of the item to make sure we target the right item. If we weren't iterating over the array already, we could use ",(0,r.jsx)(t.code,{children:".find()"})," to determine the index of the item we need."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'  <div className="task" key={index}>\n    <input\n      type="checkbox"\n      checked={done}\n      onChange={() =>\n        changeDoc((d) => {\n          d.tasks[index].done = !d.tasks[index].done;\n        })\n      }\n    />\n'})}),"\n",(0,r.jsx)(t.h3,{id:"updating-text",children:"Updating text"}),"\n",(0,r.jsx)(t.p,{children:"Finally, we're going to handle text a little differently in this example. Following the same principle we discuss above, if you reassign a text field in an Automerge document, we will replace the whole string. This might be what you want in some cases, but often, you'll want to support collaborative editing. This can be particularly important on large documents."}),"\n",(0,r.jsxs)(t.p,{children:["There are two approaches you can use here. The simplest approach is to use the utility function ",(0,r.jsx)(t.code,{children:"updateText"}),". It compares the before-and-after values of a string and applies a minimum edit script to combine the two. Typically for a more advanced integration with a text editor, you would use the ",(0,r.jsx)(t.code,{children:"Automerge.splice()"})," function as part of an event handler, or -- ideally -- you'd just use an existing text-editor plugin like ",(0,r.jsx)(t.code,{children:"@automerge/codemirror"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["First, we'll add ",(0,r.jsx)(t.code,{children:"updateText"})," to our imports from the library."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'import { updateText } from "@automerge/react";\n'})}),"\n",(0,r.jsx)(t.p,{children:"Next, we replace the text updating function with one that uses it instead of just replacing the value completely."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'    <input\n      type="text"\n      placeholder="What needs doing?"\n      value={title || ""}\n      onChange={(e) =>\n        changeDoc((doc) =>\n          updateText(\n            doc, // the document to update\n            ["tasks", 0, "title"], // array representing the path to the text to update\n            e.target.value\n          )\n        )\n      }\n      style={done ? { textDecoration: "line-through" } : {}}\n    />\n'})}),"\n",(0,r.jsx)(t.h2,{id:"collaboration-in-automerge",children:"Collaboration in Automerge"}),"\n",(0,r.jsxs)(t.p,{children:["As the name implies, one of the key powers of Automerge is its ability to ",(0,r.jsx)(t.a,{href:"/docs/under-the-hood/merge_rules/",children:"merge"})," different changes to a given document, much like git lets you merge multiple edits to a given file."]}),"\n",(0,r.jsxs)(t.p,{children:["When merging different changes to the same property, Automerge uses various strategies to avoid ",(0,r.jsx)(t.a,{href:"https://automerge.org/docs/documents/conflicts/",children:"conflicts"})," and ensure that the merged document will be identical for every user."]}),"\n",(0,r.jsx)(t.p,{children:"This makes Automerge an ideal tool for building collaborative apps that let multiple users work together on the same documents (with or without a network connection)."}),"\n",(0,r.jsx)(t.h3,{id:"collaborating-locally",children:"Collaborating Locally"}),"\n",(0,r.jsxs)(t.p,{children:["Since the Repo in this app uses a ",(0,r.jsx)(t.code,{children:"BroadcastChannelNetworkAdapter"}),", any changes made to documents in that Repo sync automatically to all other clients with the same origin (i.e. tabs within the same browser) who know the given document's URL (its unique identifier)."]}),"\n",(0,r.jsx)(t.p,{children:"Open a second tab with the same URL and edit the list, and you'll see the first tab's list updated accordingly. If you close all the tabs and reopen them, the document is preserved, as it is stored in your browser's IndexedDB."}),"\n",(0,r.jsx)(j,{src:d,alt:'Screen capture of two browser windows side-by-side showing the same app titled "Automerge Task List". As the user clicks buttons, enters text or checks boxes in one window, their changes show up immediately in the other window.',caption:"Local collaboration via the BroadcastChannelNetworkAdapter"}),"\n",(0,r.jsx)(t.p,{children:"That's right, you've already built a working Automerge-backed React app with live local synchronization! Congrats!"}),"\n",(0,r.jsx)(t.h3,{id:"collaborating-over-the-internet",children:"Collaborating over the internet"}),"\n",(0,r.jsx)(t.p,{children:"Thus far, we've been using the BroadcastChannel NetworkAdapter to move data between tabs in the same browser. Automerge treats all network adapters similarly: they are just peers you may choose to synchronize documents with."}),"\n",(0,r.jsx)(t.p,{children:"One straightforward way of getting data to other people is to send it to the cloud; then they can come along and fetch the data at their leisure."}),"\n",(0,r.jsx)(t.p,{children:'When you configure automerge to run on an internet server, listen for connections, and store data on disk, then we call that a "sync server". There\'s nothing really special about a sync server: it runs the exact same version of Auotmerge as you run locally. With a little configuration work, you could even connect to multiple sync servers and choose what data you want to send.'}),"\n",(0,r.jsxs)(t.p,{children:["The Automerge team provides a public community sync server at ",(0,r.jsx)(t.code,{children:"wss://sync.automerge.org"}),'. For production software, you should run your own server, but for prototyping and development you are welcome to use ours on an "as-is" basis.']}),"\n",(0,r.jsxs)(g,{children:[(0,r.jsx)(t.h4,{id:"connect-to-a-sync-server-via-a-websocket",children:"Connect to a sync server via a websocket"}),(0,r.jsxs)(t.p,{children:["This is as simple as adding ",(0,r.jsx)(t.code,{children:"WebSocketClientAdapter"})," to your Repo's network subsystem. We'll do this at creation time, but remember you can add and remove adapters later, too."]}),(0,r.jsx)(x,{children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/main.tsx"',children:'//...\n// highlight-next-line\nimport { WebSocketClientAdapter } from "@automerge/react";\n\nconst repo = new Repo({\n  network: [\n    new BroadcastChannelNetworkAdapter(),\n    // highlight-next-line\n    new WebSocketClientAdapter("wss://sync.automerge.org"),\n  ],\n  storage: new IndexedDBStorageAdapter(),\n});\n'})})})]}),"\n",(0,r.jsxs)(t.p,{children:["Now, when the Repo sees any changes it will sync them not only locally via the BroadcastChannel, but also over a websocket connection to ",(0,r.jsx)(t.code,{children:"sync.automerge.org"}),", and any other process can connect to that server and use the URL to get the changes we've made."]}),"\n",(0,r.jsx)(i.A,{type:"caution",children:(0,r.jsxs)(t.p,{children:["The Automerge project provides a public sync server for you to experiment with, at ",(0,r.jsx)(t.code,{children:"sync.automerge.org"}),". This is not a private instance, and as an experimental service has no reliability or data safety guarantees. Feel free to use it for demos and prototyping, but run your own sync server for production apps."]})}),"\n",(0,r.jsxs)(t.p,{children:["To see this in action, open the same URL (including the document ID) in a different browser, or on a different device. Unlike the local-only version, you'll now see the data updates synced across ",(0,r.jsx)(t.em,{children:"all"})," open clients."]}),"\n",(0,r.jsx)(t.h3,{id:"network-not-required",children:"Network Not Required"}),"\n",(0,r.jsx)(t.p,{children:"Now that the Repo is syncing changes remotely, what happens when the websocket connection is unavailable?"}),"\n",(0,r.jsxs)(t.p,{children:["Since the repo stores documents locally with the ",(0,r.jsx)(t.code,{children:"IndexedDBStorageAdapter"}),", methods like ",(0,r.jsx)(t.code,{children:"Repo.find"})," will consult local storage to retrieve/modify documents, so clients can create new documents while disconnected, and any clients who've already loaded a given document will still be able to make changes to it while offline."]}),"\n",(0,r.jsx)(t.p,{children:"Once connectivity has been re-established, the Repo will sync any local changes with those from remote peers, so everyone ultimately sees the same data."}),"\n",(0,r.jsx)(t.p,{children:"Go ahead and experiment with this by opening your site in two browsers, turning off wifi, making some changes, and turning it back on."}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(t.p,{children:"Congratulations! You've built a local-first, offline-capable app that supports multiplayer collaboration locally and over the network."}),"\n",(0,r.jsx)(t.p,{children:"If you're hungry for more:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Look at the ",(0,r.jsx)(t.a,{href:"/docs/cookbook/modeling-data/",children:"Cookbook"})," section for tips on how to model your app's data in Automerge"]}),"\n",(0,r.jsxs)(t.li,{children:["Dive deeper into how Automerge ",(0,r.jsx)(t.a,{href:"https://automerge.org/docs/under-the-hood/storage/",children:"stores"})," and ",(0,r.jsx)(t.a,{href:"https://automerge.org/docs/under-the-hood/merge_rules/",children:"merges"})," documents in the 'Under the Hood' section"]}),"\n",(0,r.jsxs)(t.li,{children:["Join the ",(0,r.jsx)(t.a,{href:"https://discord.gg/zKGe4DCfgR",children:"Discord"})," to ask questions, show off your Automerge apps, and connect with the Automerge team & community"]}),"\n"]})]})}function f(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}}}]);