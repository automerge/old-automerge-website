"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4424],{4331:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var s=n(758);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}},7790:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"reference/documents/lists","title":"Lists","description":"JavaScript Arrays are fully supported in Automerge. You can use push, unshift, insertAt, deleteAt, splice, loops, and nested objects.","source":"@site/docs/reference/documents/lists.md","sourceDirName":"reference/documents","slug":"/reference/documents/lists","permalink":"/docs/reference/documents/lists","draft":false,"unlisted":false,"editUrl":"https://github.com/automerge/automerge.github.io/edit/main/docs/reference/documents/lists.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Counters","permalink":"/docs/reference/documents/counters"},"next":{"title":"Text","permalink":"/docs/reference/documents/text"}}');var i=n(6070),o=n(4331);const r={sidebar_position:3},c="Lists",d={},a=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"lists",children:"Lists"})}),"\n",(0,i.jsxs)(t.p,{children:["JavaScript Arrays are fully supported in Automerge. You can use ",(0,i.jsx)(t.code,{children:"push"}),", ",(0,i.jsx)(t.code,{children:"unshift"}),", ",(0,i.jsx)(t.code,{children:"insertAt"}),", ",(0,i.jsx)(t.code,{children:"deleteAt"}),", ",(0,i.jsx)(t.code,{children:"splice"}),", loops, and nested objects."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"newDoc = Automerge.change(currentDoc, (doc) => {\n  doc.list = []; // creates an empty list object\n  doc.list.push(2, 3);\n  doc.list.unshift(0, 1); // unshift() adds elements at the beginning\n  doc.list[3] = Math.PI; // overwriting list element by index\n  // now doc.list is [0, 1, 2, 3.141592653589793]\n  // Looping over lists works as you'd expect:\n  for (let i = 0; i < doc.list.length; i++) doc.list[i] *= 2;\n  // now doc.list is [0, 2, 4, 6.283185307179586]\n  doc.list.splice(2, 2, \"automerge\");\n  // now doc.list is [0, 'hello', 'automerge', 4]\n  doc.list[4] = { key: \"value\" }; // objects can be nested inside lists as well\n  // Arrays in Automerge offer the convenience functions `insertAt` and `deleteAt`\n  doc.list.insertAt(1, \"hello\", \"world\"); // inserts elements at given index\n  doc.list.deleteAt(5); // deletes element at given index\n  // now doc.list is [0, 'hello', 'world', 2, 4]\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you have previously worked with immutable state in JavaScript, you might be in the habit of\nusing ",(0,i.jsx)(t.a,{href:"https://redux.js.org/recipes/structuring-reducers/updating-normalized-data",children:"idioms like these"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'state = Automerge.change(state, "Add card", (doc) => {\n  const newItem = { id: 123, title: "Rewrite everything in Rust", done: false };\n  doc.cards = {\n    ids: [...doc.cards.ids, newItem.id],\n    entities: { ...doc.cards.entities, [newItem.id]: newItem },\n  };\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["While this pattern works fine outside of Automerge, please ",(0,i.jsx)(t.strong,{children:"don't do this in Automerge"}),"! Please\nuse mutable idioms to update the state instead, like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'state = Automerge.change(state, "Add card", (doc) => {\n  const newItem = { id: 123, title: "Rewrite everything in Rust", done: false };\n  doc.cards.ids.push(newItem.id);\n  doc.cards.entities[newItem.id] = newItem;\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Even though you are using mutating APIs, Automerge ensures that the code above does not actually\nmutate ",(0,i.jsx)(t.code,{children:"state"}),", but returns a new copy of ",(0,i.jsx)(t.code,{children:"state"})," in which the changes are reflected. The problem\nwith the first example is that from Automerge's point of view, you are replacing the entire\n",(0,i.jsx)(t.code,{children:"doc.cards"})," object (and everything inside it) with a brand new object. Thus, if two users\nconcurrently update the document, Automerge will not be able to merge those changes (instead, you\nwill just get a conflict on the ",(0,i.jsx)(t.code,{children:"doc.cards"})," property)."]}),"\n",(0,i.jsxs)(t.p,{children:["You can avoid this problem by making the changes at a fine-grained level: adding one\nitem to the array of IDs with ",(0,i.jsx)(t.code,{children:"ids.push(newItem.id)"}),", and adding one item to the map of entities\nwith ",(0,i.jsx)(t.code,{children:"entities[newItem.id] = newItem"}),". This code works much better, since it tells Automerge\nexactly which changes you are making to the state, and this information allows Automerge to deal\nmuch better with concurrent updates by different users."]}),"\n",(0,i.jsx)(t.p,{children:"As a general principle with Automerge, you should make state updates at the most fine-grained\nlevel possible. Don't replace an entire object if you're only modifying one property of that\nobject; just assign that one property instead."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);